// WARNING!  This file was automatically generated by macexp.
//           Do not edit this file, any changes made will be lost.

`celldefine

// macexp DFF 5
// macexp $size 6
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_6 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_6 "true";
	input clk;
	input [5:0] d;
	output [5:0] q;
	reg [5:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 18
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_18 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_18 "true";
	input clk;
	input reset;
	input [17:0] d;
	output [17:0] q;
	reg [17:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 18'b0;
	else
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 13
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_13 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_13 "true";
	input clk;
	input [12:0] d;
	output [12:0] q;
	reg [12:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 13
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_13 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_13 "true";
	input clk;
	input reset;
	input [12:0] d;
	output [12:0] q;
	reg [12:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 13'b0;
	else
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 10
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_10 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_10 "true";
	input clk;
	input [9:0] d;
	output [9:0] q;
	reg [9:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 3
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_3 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_3 "true";
	input clk;
	input [2:0] d;
	output [2:0] q;
	reg [2:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 6
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_6 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_6 "true";
	input clk;
	input reset;
	input [5:0] d;
	output [5:0] q;
	reg [5:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 6'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFS 6
// macexp $size 2
// macexp $instance
// macexp clk
// macexp set
// macexp d
// macexp q

module dffs_2 ( clk, set, d, q );
	// synthesis attribute keep_hierarchy dffs_2 "true";
	input clk;
	input set;
	input [1:0] d;
	output [1:0] q;
	reg [1:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (set)
	q <= ~(2'b0);
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 4
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_4 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_4 "true";
	input clk;
	input reset;
	input [3:0] d;
	output [3:0] q;
	reg [3:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 4'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFS 6
// macexp $size 35
// macexp $instance
// macexp clk
// macexp set
// macexp d
// macexp q

module dffs_35 ( clk, set, d, q );
	// synthesis attribute keep_hierarchy dffs_35 "true";
	input clk;
	input set;
	input [34:0] d;
	output [34:0] q;
	reg [34:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (set)
	q <= ~(35'b0);
	else
	q <= d;
	end
endmodule

// macexp DFFS 6
// macexp $size 37
// macexp $instance
// macexp clk
// macexp set
// macexp d
// macexp q

module dffs_37 ( clk, set, d, q );
	// synthesis attribute keep_hierarchy dffs_37 "true";
	input clk;
	input set;
	input [36:0] d;
	output [36:0] q;
	reg [36:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (set)
	q <= ~(37'b0);
	else
	q <= d;
	end
endmodule

// macexp DFFS 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp set
// macexp d
// macexp q

module dffs_1 ( clk, set, d, q );
	// synthesis attribute keep_hierarchy dffs_1 "true";
	input clk;
	input set;
	input d;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (set)
	q <= ~(1'b0);
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 7
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_7 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_7 "true";
	input clk;
	input reset;
	input [6:0] d;
	output [6:0] q;
	reg [6:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 7'b0;
	else
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 5
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_5 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_5 "true";
	input clk;
	input [4:0] d;
	output [4:0] q;
	reg [4:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 37
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_37 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_37 "true";
	input clk;
	input [36:0] d;
	output [36:0] q;
	reg [36:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFSI 7
// macexp $size 10
// macexp $instance
// macexp clk
// macexp reset
// macexp init
// macexp d
// macexp q

module dffsi_10 ( clk, reset, init, d, q );
	// synthesis attribute keep_hierarchy dffsi_10 "true";
	input clk;
	input reset;
	input [9:0] init;
	input [9:0] d;
	output [9:0] q;
	reg [9:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= init;
	else
	q <= d;
	end
endmodule

// macexp DFFCL 7
// macexp $size 9
// macexp $instance
// macexp clk
// macexp reset
// macexp ld
// macexp d
// macexp q

module dffcl_9 ( clk, reset, ld, d, q );
	// synthesis attribute keep_hierarchy dffcl_9 "true";
	input clk;
	input reset;
	input ld;
	input [8:0] d;
	output [8:0] q;
	reg [8:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 9'b0;
	else begin
	// leda XV2P_1006 off Multiple synchronous resets detected
	// leda XV2P_1007 off Multiple synchronous resets detected
	// leda G_551_1_K off Multiple synchronous resets detected
	if (ld)
	q <= d;
	// leda XV2P_1006 on Multiple synchronous resets detected
	// leda XV2P_1007 on Multiple synchronous resets detected
	// leda G_551_1_K on Multiple synchronous resets detected
	end
	end
endmodule

// macexp DFF 5
// macexp $size 9
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_9 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_9 "true";
	input clk;
	input [8:0] d;
	output [8:0] q;
	reg [8:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 32
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_32 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_32 "true";
	input clk;
	input reset;
	input [31:0] d;
	output [31:0] q;
	reg [31:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 32'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 17
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_17 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_17 "true";
	input clk;
	input reset;
	input [16:0] d;
	output [16:0] q;
	reg [16:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 17'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 64
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_64 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_64 "true";
	input clk;
	input reset;
	input [63:0] d;
	output [63:0] q;
	reg [63:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 64'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 48
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_48 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_48 "true";
	input clk;
	input reset;
	input [47:0] d;
	output [47:0] q;
	reg [47:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 48'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 3
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_3 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_3 "true";
	input clk;
	input reset;
	input [2:0] d;
	output [2:0] q;
	reg [2:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 3'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFSI 7
// macexp $size 4
// macexp $instance
// macexp clk
// macexp reset
// macexp init
// macexp d
// macexp q

module dffsi_4 ( clk, reset, init, d, q );
	// synthesis attribute keep_hierarchy dffsi_4 "true";
	input clk;
	input reset;
	input [3:0] init;
	input [3:0] d;
	output [3:0] q;
	reg [3:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= init;
	else
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 48
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_48 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_48 "true";
	input clk;
	input [47:0] d;
	output [47:0] q;
	reg [47:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 2
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_2 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_2 "true";
	input clk;
	input [1:0] d;
	output [1:0] q;
	reg [1:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 64
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_64 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_64 "true";
	input clk;
	input [63:0] d;
	output [63:0] q;
	reg [63:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_1 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_1 "true";
	input clk;
	input d;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 2
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_2 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_2 "true";
	input clk;
	input reset;
	input [1:0] d;
	output [1:0] q;
	reg [1:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 2'b0;
	else
	q <= d;
	end
endmodule

// macexp RESET_FLOP 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp i_reset
// macexp reset

module reset_flop_1 ( clk, i_reset, reset );
	// synthesis attribute keep_hierarchy reset_flop_1 "true";
	// synthesis attribute equivalent_register_removal reset_flop_1 "no";
	// synthesis attribute shift_extract reset_flop_1 "no";
	// synthesis attribute shreg_extract reset_flop_1 "no";
	input clk;
	input i_reset;
	// synthesis attribute keep reset "true";
	output reset;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: i_reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(i_reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	wire my_zero;
	(* S = "TRUE" *)
	LUT1_L #(
	.INIT(2'h0)
	) lut0 (
	.LO(my_zero),
	.I0(reset)
	);
	(* S = "TRUE" *)
	FDS q0 (
	.Q(reset),
	.C(clk),
	.S(i_reset),
	.D(my_zero)
	);
endmodule

// macexp DFFC 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_1 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_1 "true";
	input clk;
	input reset;
	input d;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 1'b0;
	else
	q <= d;
	end
endmodule

// macexp PEXT_P2 5
// macexp $instance
// macexp $cycles 4
// macexp clk
// macexp d
// macexp q

module pext_p2_4 ( clk, d, q );
	// synthesis attribute keep_hierarchy pext_p2_4 "true";
	input clk;
	input d;
	output q;
	reg q;
	reg c_q;
	reg [1:0] r_cnt;
	reg [1:0] c_cnt;
	reg [1:0] cig_zerocnt;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial begin
	$random_init("q", "r_cnt");
	end
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	r_cnt <= // synthesis translate_off
	(^c_cnt === 1'bx) ? $random :
	// synthesis translate_on
	c_cnt;
	q <= c_q;
	end
	always @ (d or q or r_cnt) begin
	cig_zerocnt = 2'b0;
	c_cnt = d ? ~cig_zerocnt : {r_cnt - ((|r_cnt) ? 2'b1 : 2'b0)};
	c_q = d | (|r_cnt);
	end
endmodule

// macexp DFF_KEEP 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_1 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_1 "true";
	// synthesis attribute equivalent_register_removal dff_keep_1 "no";
	// synthesis attribute shift_extract dff_keep_1 "no";
	// synthesis attribute shreg_extract dff_keep_1 "no";
	input clk;
	input d;
	// synthesis attribute keep q "true";
	output q;
	(* S = "TRUE" *)
	FD q0 (
	.Q(q),
	.C(clk),
	.D(d)
	);
endmodule

// macexp PHASEGEN 7
// macexp $size 1
// macexp $instance
// macexp clk
// macexp clk_2x
// macexp set
// macexp phase
// macexp reset

module phasegen_1 ( clk, clk_2x, set, phase, reset );
	// synthesis attribute keep_hierarchy phasegen_1 "true";
	// synthesis attribute equivalent_register_removal phasegen_1 "no";
	// synthesis attribute shift_extract phasegen_1 "no";
	// synthesis attribute shreg_extract phasegen_1 "no";
	input clk;
	input clk_2x;
	input set;
	output phase;
	output reset;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	wire my_zero, set_ls;
	assign reset = set_ls;
	LUT1_L #(
	.INIT(2'h0)
	) rset_ls_lut (
	.LO(my_zero),
	.I0(set_ls)
	);
	FDS rset_ls (
	.Q(set_ls), 
	.C(clk), 
	.D(my_zero), 
	.S(set)
	);
	FDS rphase (
	.Q(phase), 
	.C(clk_2x), 
	.D(~phase), 
	.S(set_ls)
	);
endmodule

// macexp DFF 5
// macexp $size 17
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_17 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_17 "true";
	input clk;
	input [16:0] d;
	output [16:0] q;
	reg [16:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF_KEEP 5
// macexp $size 2
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_2 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_2 "true";
	// synthesis attribute equivalent_register_removal dff_keep_2 "no";
	// synthesis attribute shift_extract dff_keep_2 "no";
	// synthesis attribute shreg_extract dff_keep_2 "no";
	input clk;
	input [1:0] d;
	// synthesis attribute keep q "true";
	output [1:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
endmodule

// macexp DFF_KEEP 5
// macexp $size 48
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_48 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_48 "true";
	// synthesis attribute equivalent_register_removal dff_keep_48 "no";
	// synthesis attribute shift_extract dff_keep_48 "no";
	// synthesis attribute shreg_extract dff_keep_48 "no";
	input clk;
	input [47:0] d;
	// synthesis attribute keep q "true";
	output [47:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
	(* S = "TRUE" *)
	FD q_9 (
	.Q(q[9]),
	.C(clk),
	.D(d[9])
	);
	(* S = "TRUE" *)
	FD q_10 (
	.Q(q[10]),
	.C(clk),
	.D(d[10])
	);
	(* S = "TRUE" *)
	FD q_11 (
	.Q(q[11]),
	.C(clk),
	.D(d[11])
	);
	(* S = "TRUE" *)
	FD q_12 (
	.Q(q[12]),
	.C(clk),
	.D(d[12])
	);
	(* S = "TRUE" *)
	FD q_13 (
	.Q(q[13]),
	.C(clk),
	.D(d[13])
	);
	(* S = "TRUE" *)
	FD q_14 (
	.Q(q[14]),
	.C(clk),
	.D(d[14])
	);
	(* S = "TRUE" *)
	FD q_15 (
	.Q(q[15]),
	.C(clk),
	.D(d[15])
	);
	(* S = "TRUE" *)
	FD q_16 (
	.Q(q[16]),
	.C(clk),
	.D(d[16])
	);
	(* S = "TRUE" *)
	FD q_17 (
	.Q(q[17]),
	.C(clk),
	.D(d[17])
	);
	(* S = "TRUE" *)
	FD q_18 (
	.Q(q[18]),
	.C(clk),
	.D(d[18])
	);
	(* S = "TRUE" *)
	FD q_19 (
	.Q(q[19]),
	.C(clk),
	.D(d[19])
	);
	(* S = "TRUE" *)
	FD q_20 (
	.Q(q[20]),
	.C(clk),
	.D(d[20])
	);
	(* S = "TRUE" *)
	FD q_21 (
	.Q(q[21]),
	.C(clk),
	.D(d[21])
	);
	(* S = "TRUE" *)
	FD q_22 (
	.Q(q[22]),
	.C(clk),
	.D(d[22])
	);
	(* S = "TRUE" *)
	FD q_23 (
	.Q(q[23]),
	.C(clk),
	.D(d[23])
	);
	(* S = "TRUE" *)
	FD q_24 (
	.Q(q[24]),
	.C(clk),
	.D(d[24])
	);
	(* S = "TRUE" *)
	FD q_25 (
	.Q(q[25]),
	.C(clk),
	.D(d[25])
	);
	(* S = "TRUE" *)
	FD q_26 (
	.Q(q[26]),
	.C(clk),
	.D(d[26])
	);
	(* S = "TRUE" *)
	FD q_27 (
	.Q(q[27]),
	.C(clk),
	.D(d[27])
	);
	(* S = "TRUE" *)
	FD q_28 (
	.Q(q[28]),
	.C(clk),
	.D(d[28])
	);
	(* S = "TRUE" *)
	FD q_29 (
	.Q(q[29]),
	.C(clk),
	.D(d[29])
	);
	(* S = "TRUE" *)
	FD q_30 (
	.Q(q[30]),
	.C(clk),
	.D(d[30])
	);
	(* S = "TRUE" *)
	FD q_31 (
	.Q(q[31]),
	.C(clk),
	.D(d[31])
	);
	(* S = "TRUE" *)
	FD q_32 (
	.Q(q[32]),
	.C(clk),
	.D(d[32])
	);
	(* S = "TRUE" *)
	FD q_33 (
	.Q(q[33]),
	.C(clk),
	.D(d[33])
	);
	(* S = "TRUE" *)
	FD q_34 (
	.Q(q[34]),
	.C(clk),
	.D(d[34])
	);
	(* S = "TRUE" *)
	FD q_35 (
	.Q(q[35]),
	.C(clk),
	.D(d[35])
	);
	(* S = "TRUE" *)
	FD q_36 (
	.Q(q[36]),
	.C(clk),
	.D(d[36])
	);
	(* S = "TRUE" *)
	FD q_37 (
	.Q(q[37]),
	.C(clk),
	.D(d[37])
	);
	(* S = "TRUE" *)
	FD q_38 (
	.Q(q[38]),
	.C(clk),
	.D(d[38])
	);
	(* S = "TRUE" *)
	FD q_39 (
	.Q(q[39]),
	.C(clk),
	.D(d[39])
	);
	(* S = "TRUE" *)
	FD q_40 (
	.Q(q[40]),
	.C(clk),
	.D(d[40])
	);
	(* S = "TRUE" *)
	FD q_41 (
	.Q(q[41]),
	.C(clk),
	.D(d[41])
	);
	(* S = "TRUE" *)
	FD q_42 (
	.Q(q[42]),
	.C(clk),
	.D(d[42])
	);
	(* S = "TRUE" *)
	FD q_43 (
	.Q(q[43]),
	.C(clk),
	.D(d[43])
	);
	(* S = "TRUE" *)
	FD q_44 (
	.Q(q[44]),
	.C(clk),
	.D(d[44])
	);
	(* S = "TRUE" *)
	FD q_45 (
	.Q(q[45]),
	.C(clk),
	.D(d[45])
	);
	(* S = "TRUE" *)
	FD q_46 (
	.Q(q[46]),
	.C(clk),
	.D(d[46])
	);
	(* S = "TRUE" *)
	FD q_47 (
	.Q(q[47]),
	.C(clk),
	.D(d[47])
	);
endmodule

// macexp DFF_KEEP 5
// macexp $size 64
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_64 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_64 "true";
	// synthesis attribute equivalent_register_removal dff_keep_64 "no";
	// synthesis attribute shift_extract dff_keep_64 "no";
	// synthesis attribute shreg_extract dff_keep_64 "no";
	input clk;
	input [63:0] d;
	// synthesis attribute keep q "true";
	output [63:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
	(* S = "TRUE" *)
	FD q_9 (
	.Q(q[9]),
	.C(clk),
	.D(d[9])
	);
	(* S = "TRUE" *)
	FD q_10 (
	.Q(q[10]),
	.C(clk),
	.D(d[10])
	);
	(* S = "TRUE" *)
	FD q_11 (
	.Q(q[11]),
	.C(clk),
	.D(d[11])
	);
	(* S = "TRUE" *)
	FD q_12 (
	.Q(q[12]),
	.C(clk),
	.D(d[12])
	);
	(* S = "TRUE" *)
	FD q_13 (
	.Q(q[13]),
	.C(clk),
	.D(d[13])
	);
	(* S = "TRUE" *)
	FD q_14 (
	.Q(q[14]),
	.C(clk),
	.D(d[14])
	);
	(* S = "TRUE" *)
	FD q_15 (
	.Q(q[15]),
	.C(clk),
	.D(d[15])
	);
	(* S = "TRUE" *)
	FD q_16 (
	.Q(q[16]),
	.C(clk),
	.D(d[16])
	);
	(* S = "TRUE" *)
	FD q_17 (
	.Q(q[17]),
	.C(clk),
	.D(d[17])
	);
	(* S = "TRUE" *)
	FD q_18 (
	.Q(q[18]),
	.C(clk),
	.D(d[18])
	);
	(* S = "TRUE" *)
	FD q_19 (
	.Q(q[19]),
	.C(clk),
	.D(d[19])
	);
	(* S = "TRUE" *)
	FD q_20 (
	.Q(q[20]),
	.C(clk),
	.D(d[20])
	);
	(* S = "TRUE" *)
	FD q_21 (
	.Q(q[21]),
	.C(clk),
	.D(d[21])
	);
	(* S = "TRUE" *)
	FD q_22 (
	.Q(q[22]),
	.C(clk),
	.D(d[22])
	);
	(* S = "TRUE" *)
	FD q_23 (
	.Q(q[23]),
	.C(clk),
	.D(d[23])
	);
	(* S = "TRUE" *)
	FD q_24 (
	.Q(q[24]),
	.C(clk),
	.D(d[24])
	);
	(* S = "TRUE" *)
	FD q_25 (
	.Q(q[25]),
	.C(clk),
	.D(d[25])
	);
	(* S = "TRUE" *)
	FD q_26 (
	.Q(q[26]),
	.C(clk),
	.D(d[26])
	);
	(* S = "TRUE" *)
	FD q_27 (
	.Q(q[27]),
	.C(clk),
	.D(d[27])
	);
	(* S = "TRUE" *)
	FD q_28 (
	.Q(q[28]),
	.C(clk),
	.D(d[28])
	);
	(* S = "TRUE" *)
	FD q_29 (
	.Q(q[29]),
	.C(clk),
	.D(d[29])
	);
	(* S = "TRUE" *)
	FD q_30 (
	.Q(q[30]),
	.C(clk),
	.D(d[30])
	);
	(* S = "TRUE" *)
	FD q_31 (
	.Q(q[31]),
	.C(clk),
	.D(d[31])
	);
	(* S = "TRUE" *)
	FD q_32 (
	.Q(q[32]),
	.C(clk),
	.D(d[32])
	);
	(* S = "TRUE" *)
	FD q_33 (
	.Q(q[33]),
	.C(clk),
	.D(d[33])
	);
	(* S = "TRUE" *)
	FD q_34 (
	.Q(q[34]),
	.C(clk),
	.D(d[34])
	);
	(* S = "TRUE" *)
	FD q_35 (
	.Q(q[35]),
	.C(clk),
	.D(d[35])
	);
	(* S = "TRUE" *)
	FD q_36 (
	.Q(q[36]),
	.C(clk),
	.D(d[36])
	);
	(* S = "TRUE" *)
	FD q_37 (
	.Q(q[37]),
	.C(clk),
	.D(d[37])
	);
	(* S = "TRUE" *)
	FD q_38 (
	.Q(q[38]),
	.C(clk),
	.D(d[38])
	);
	(* S = "TRUE" *)
	FD q_39 (
	.Q(q[39]),
	.C(clk),
	.D(d[39])
	);
	(* S = "TRUE" *)
	FD q_40 (
	.Q(q[40]),
	.C(clk),
	.D(d[40])
	);
	(* S = "TRUE" *)
	FD q_41 (
	.Q(q[41]),
	.C(clk),
	.D(d[41])
	);
	(* S = "TRUE" *)
	FD q_42 (
	.Q(q[42]),
	.C(clk),
	.D(d[42])
	);
	(* S = "TRUE" *)
	FD q_43 (
	.Q(q[43]),
	.C(clk),
	.D(d[43])
	);
	(* S = "TRUE" *)
	FD q_44 (
	.Q(q[44]),
	.C(clk),
	.D(d[44])
	);
	(* S = "TRUE" *)
	FD q_45 (
	.Q(q[45]),
	.C(clk),
	.D(d[45])
	);
	(* S = "TRUE" *)
	FD q_46 (
	.Q(q[46]),
	.C(clk),
	.D(d[46])
	);
	(* S = "TRUE" *)
	FD q_47 (
	.Q(q[47]),
	.C(clk),
	.D(d[47])
	);
	(* S = "TRUE" *)
	FD q_48 (
	.Q(q[48]),
	.C(clk),
	.D(d[48])
	);
	(* S = "TRUE" *)
	FD q_49 (
	.Q(q[49]),
	.C(clk),
	.D(d[49])
	);
	(* S = "TRUE" *)
	FD q_50 (
	.Q(q[50]),
	.C(clk),
	.D(d[50])
	);
	(* S = "TRUE" *)
	FD q_51 (
	.Q(q[51]),
	.C(clk),
	.D(d[51])
	);
	(* S = "TRUE" *)
	FD q_52 (
	.Q(q[52]),
	.C(clk),
	.D(d[52])
	);
	(* S = "TRUE" *)
	FD q_53 (
	.Q(q[53]),
	.C(clk),
	.D(d[53])
	);
	(* S = "TRUE" *)
	FD q_54 (
	.Q(q[54]),
	.C(clk),
	.D(d[54])
	);
	(* S = "TRUE" *)
	FD q_55 (
	.Q(q[55]),
	.C(clk),
	.D(d[55])
	);
	(* S = "TRUE" *)
	FD q_56 (
	.Q(q[56]),
	.C(clk),
	.D(d[56])
	);
	(* S = "TRUE" *)
	FD q_57 (
	.Q(q[57]),
	.C(clk),
	.D(d[57])
	);
	(* S = "TRUE" *)
	FD q_58 (
	.Q(q[58]),
	.C(clk),
	.D(d[58])
	);
	(* S = "TRUE" *)
	FD q_59 (
	.Q(q[59]),
	.C(clk),
	.D(d[59])
	);
	(* S = "TRUE" *)
	FD q_60 (
	.Q(q[60]),
	.C(clk),
	.D(d[60])
	);
	(* S = "TRUE" *)
	FD q_61 (
	.Q(q[61]),
	.C(clk),
	.D(d[61])
	);
	(* S = "TRUE" *)
	FD q_62 (
	.Q(q[62]),
	.C(clk),
	.D(d[62])
	);
	(* S = "TRUE" *)
	FD q_63 (
	.Q(q[63]),
	.C(clk),
	.D(d[63])
	);
endmodule

// macexp DFF 5
// macexp $size 4
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_4 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_4 "true";
	input clk;
	input [3:0] d;
	output [3:0] q;
	reg [3:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 32
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_32 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_32 "true";
	input clk;
	input [31:0] d;
	output [31:0] q;
	reg [31:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp PEXT 6
// macexp $instance
// macexp $cycles 8
// macexp clk
// macexp reset
// macexp d
// macexp q

module gen_pext_8 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy gen_pext_8 "true";
	input clk;
	input reset;
	input d;
	output q;
	reg q;
	reg c_q;
	reg c_zerocnt;
	reg c_gemaxcnt;
	reg [2:0] r_cnt;
	reg [2:0] c_cnt;
	reg [2:0] c_ifcnt0;
	reg [2:0] c_inccnt;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial begin
	$random_init("q", "r_cnt");
	end
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0,
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset) begin
	q <= 1'h0;
	r_cnt <= 3'b0;
	end
	else begin
	q <= c_q;
	r_cnt <= c_cnt;
	end
	end
	always @ (d or q or r_cnt) begin
	c_zerocnt = ~(|r_cnt);
	c_q = c_zerocnt ? d : q;
	c_ifcnt0 = c_q ? 3'h1 : 3'h0;
	c_inccnt = {r_cnt + 3'h1};
	c_gemaxcnt = (r_cnt >= 3'd 7);
	c_cnt = c_zerocnt ? c_ifcnt0 : 
	(c_gemaxcnt ? 3'h0 : c_inccnt);
	end
endmodule

// macexp DFF 5
// macexp $size 18
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_18 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_18 "true";
	input clk;
	input [17:0] d;
	output [17:0] q;
	reg [17:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 8
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_8 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_8 "true";
	input clk;
	input [7:0] d;
	output [7:0] q;
	reg [7:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 9
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_9 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_9 "true";
	input clk;
	input reset;
	input [8:0] d;
	output [8:0] q;
	reg [8:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 9'b0;
	else
	q <= d;
	end
endmodule

// macexp SYNC2R 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp preset
// macexp d
// macexp q

module sync2r_1 ( clk, preset, d, q );
	// synthesis attribute keep_hierarchy sync2r_1 "true";
	// synthesis attribute equivalent_register_removal sync2r_1 "no";
	// synthesis attribute register_duplication sync2r_1 "no";
	// synthesis attribute shift_extract sync2r_1 "no";
	// synthesis attribute shreg_extract sync2r_1 "no";
	input clk;
	input preset;
	input d;
	output q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ q;
	reg c_q;
	// synthesis attribute keep meta1 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg c_meta2;
	reg meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk or posedge preset) begin
	if (preset) begin
	meta1 <= ~(1'b0);
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= ~(1'b0);
`endif
	// synopsys translate_on
	q <= ~(1'b0);
	end else begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
	end
endmodule

// macexp DLY100_SEL 5
// macexp $depth 3
// macexp $size 1
// macexp $instance
// macexp i
// macexp o

module dly3_1 ( i, o );
	input i;
	output o;
	wire n0;
	wire n1;
	wire n2;
	wire n3;
	assign n0 = i;
	(* S = "TRUE" *)
	BUF dly0 (.I(n0), .O(n1));
	(* S = "TRUE" *)
	BUF dly1 (.I(n1), .O(n2));
	(* S = "TRUE" *)
	BUF dly2 (.I(n2), .O(n3));
	assign o = n3;
endmodule

// macexp SYNC2R_F 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp clear
// macexp d
// macexp q

module sync2r_f_1 ( clk, clear, d, q );
	// synthesis attribute keep_hierarchy sync2r_f_1 "true";
	// synthesis attribute equivalent_register_removal sync2r_f_1 "no";
	// synthesis attribute register_duplication sync2r_f_1 "no";
	// synthesis attribute shift_extract sync2r_f_1 "no";
	// synthesis attribute shreg_extract sync2r_f_1 "no";
	input clk;
	input clear;
	input d;
	output q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ q;
	reg c_q;
	// synthesis attribute keep meta1 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg c_meta2;
	reg meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk or posedge clear) begin
	if (clear) begin
	meta1 <= 1'b0;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= 1'b0;
`endif
	// synopsys translate_on
	q <= 1'b0;
	end else begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
	end
endmodule

// macexp BIDI_IO 6
// macexp $size 34
// macexp $instance
// macexp oe_
// macexp odata
// macexp idata
// macexp data

module bidi_io_34 ( oe_, odata, idata, data );
	// synthesis attribute keep_hierarchy bidi_io_34 "true";
	input [33:0] oe_;
	input [33:0] odata;
	output [33:0] idata;
	inout [33:0] data;
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf0 (.I(odata[0]), .T(oe_[0]), .O(idata[0]), .IO(data[0]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf1 (.I(odata[1]), .T(oe_[1]), .O(idata[1]), .IO(data[1]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf2 (.I(odata[2]), .T(oe_[2]), .O(idata[2]), .IO(data[2]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf3 (.I(odata[3]), .T(oe_[3]), .O(idata[3]), .IO(data[3]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf4 (.I(odata[4]), .T(oe_[4]), .O(idata[4]), .IO(data[4]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf5 (.I(odata[5]), .T(oe_[5]), .O(idata[5]), .IO(data[5]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf6 (.I(odata[6]), .T(oe_[6]), .O(idata[6]), .IO(data[6]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf7 (.I(odata[7]), .T(oe_[7]), .O(idata[7]), .IO(data[7]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf8 (.I(odata[8]), .T(oe_[8]), .O(idata[8]), .IO(data[8]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf9 (.I(odata[9]), .T(oe_[9]), .O(idata[9]), .IO(data[9]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf10 (.I(odata[10]), .T(oe_[10]), .O(idata[10]), .IO(data[10]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf11 (.I(odata[11]), .T(oe_[11]), .O(idata[11]), .IO(data[11]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf12 (.I(odata[12]), .T(oe_[12]), .O(idata[12]), .IO(data[12]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf13 (.I(odata[13]), .T(oe_[13]), .O(idata[13]), .IO(data[13]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf14 (.I(odata[14]), .T(oe_[14]), .O(idata[14]), .IO(data[14]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf15 (.I(odata[15]), .T(oe_[15]), .O(idata[15]), .IO(data[15]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf16 (.I(odata[16]), .T(oe_[16]), .O(idata[16]), .IO(data[16]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf17 (.I(odata[17]), .T(oe_[17]), .O(idata[17]), .IO(data[17]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf18 (.I(odata[18]), .T(oe_[18]), .O(idata[18]), .IO(data[18]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf19 (.I(odata[19]), .T(oe_[19]), .O(idata[19]), .IO(data[19]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf20 (.I(odata[20]), .T(oe_[20]), .O(idata[20]), .IO(data[20]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf21 (.I(odata[21]), .T(oe_[21]), .O(idata[21]), .IO(data[21]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf22 (.I(odata[22]), .T(oe_[22]), .O(idata[22]), .IO(data[22]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf23 (.I(odata[23]), .T(oe_[23]), .O(idata[23]), .IO(data[23]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf24 (.I(odata[24]), .T(oe_[24]), .O(idata[24]), .IO(data[24]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf25 (.I(odata[25]), .T(oe_[25]), .O(idata[25]), .IO(data[25]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf26 (.I(odata[26]), .T(oe_[26]), .O(idata[26]), .IO(data[26]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf27 (.I(odata[27]), .T(oe_[27]), .O(idata[27]), .IO(data[27]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf28 (.I(odata[28]), .T(oe_[28]), .O(idata[28]), .IO(data[28]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf29 (.I(odata[29]), .T(oe_[29]), .O(idata[29]), .IO(data[29]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf30 (.I(odata[30]), .T(oe_[30]), .O(idata[30]), .IO(data[30]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf31 (.I(odata[31]), .T(oe_[31]), .O(idata[31]), .IO(data[31]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf32 (.I(odata[32]), .T(oe_[32]), .O(idata[32]), .IO(data[32]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf33 (.I(odata[33]), .T(oe_[33]), .O(idata[33]), .IO(data[33]));
endmodule

// macexp DFFS_KEEP 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp set
// macexp d
// macexp q

module dffs_keep_1 ( clk, set, d, q );
	// synthesis attribute keep_hierarchy dffs_keep_1 "true";
	// synthesis attribute equivalent_register_removal dffs_keep_1 "no";
	// synthesis attribute shift_extract dffs_keep_1 "no";
	// synthesis attribute shreg_extract dffs_keep_1 "no";
	input clk;
	input set;
	input d;
	// synthesis attribute keep q "true";
	output q;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	(* S = "TRUE" *)
	FDS q0 (
	.Q(q),
	.C(clk),
	.S(set),
	.D(d)
	);
endmodule

// macexp DFF_KEEP 5
// macexp $size 7
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_7 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_7 "true";
	// synthesis attribute equivalent_register_removal dff_keep_7 "no";
	// synthesis attribute shift_extract dff_keep_7 "no";
	// synthesis attribute shreg_extract dff_keep_7 "no";
	input clk;
	input [6:0] d;
	// synthesis attribute keep q "true";
	output [6:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
endmodule

// macexp BIDI_IO 6
// macexp $size 7
// macexp $instance
// macexp oe_
// macexp odata
// macexp idata
// macexp data

module bidi_io_7 ( oe_, odata, idata, data );
	// synthesis attribute keep_hierarchy bidi_io_7 "true";
	input [6:0] oe_;
	input [6:0] odata;
	output [6:0] idata;
	inout [6:0] data;
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf0 (.I(odata[0]), .T(oe_[0]), .O(idata[0]), .IO(data[0]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf1 (.I(odata[1]), .T(oe_[1]), .O(idata[1]), .IO(data[1]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf2 (.I(odata[2]), .T(oe_[2]), .O(idata[2]), .IO(data[2]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf3 (.I(odata[3]), .T(oe_[3]), .O(idata[3]), .IO(data[3]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf4 (.I(odata[4]), .T(oe_[4]), .O(idata[4]), .IO(data[4]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf5 (.I(odata[5]), .T(oe_[5]), .O(idata[5]), .IO(data[5]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf6 (.I(odata[6]), .T(oe_[6]), .O(idata[6]), .IO(data[6]));
endmodule

// macexp DDR_IN 6
// macexp $size 20
// macexp $instance
// macexp clk
// macexp ddr
// macexp data_hi
// macexp data_lo

module ddr_in_20 ( clk, ddr, data_hi, data_lo );
	// synthesis attribute keep_hierarchy ddr_in_20 "true";
	input clk;
	input [19:0] ddr;
	output [19:0] data_hi;
	output [19:0] data_lo;
	defparam d0.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d0 (
	.D(ddr[0]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[0]),
	.Q2(data_lo[0]));
	defparam d1.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d1 (
	.D(ddr[1]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[1]),
	.Q2(data_lo[1]));
	defparam d2.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d2 (
	.D(ddr[2]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[2]),
	.Q2(data_lo[2]));
	defparam d3.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d3 (
	.D(ddr[3]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[3]),
	.Q2(data_lo[3]));
	defparam d4.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d4 (
	.D(ddr[4]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[4]),
	.Q2(data_lo[4]));
	defparam d5.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d5 (
	.D(ddr[5]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[5]),
	.Q2(data_lo[5]));
	defparam d6.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d6 (
	.D(ddr[6]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[6]),
	.Q2(data_lo[6]));
	defparam d7.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d7 (
	.D(ddr[7]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[7]),
	.Q2(data_lo[7]));
	defparam d8.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d8 (
	.D(ddr[8]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[8]),
	.Q2(data_lo[8]));
	defparam d9.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d9 (
	.D(ddr[9]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[9]),
	.Q2(data_lo[9]));
	defparam d10.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d10 (
	.D(ddr[10]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[10]),
	.Q2(data_lo[10]));
	defparam d11.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d11 (
	.D(ddr[11]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[11]),
	.Q2(data_lo[11]));
	defparam d12.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d12 (
	.D(ddr[12]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[12]),
	.Q2(data_lo[12]));
	defparam d13.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d13 (
	.D(ddr[13]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[13]),
	.Q2(data_lo[13]));
	defparam d14.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d14 (
	.D(ddr[14]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[14]),
	.Q2(data_lo[14]));
	defparam d15.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d15 (
	.D(ddr[15]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[15]),
	.Q2(data_lo[15]));
	defparam d16.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d16 (
	.D(ddr[16]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[16]),
	.Q2(data_lo[16]));
	defparam d17.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d17 (
	.D(ddr[17]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[17]),
	.Q2(data_lo[17]));
	defparam d18.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d18 (
	.D(ddr[18]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[18]),
	.Q2(data_lo[18]));
	defparam d19.DDR_CLK_EDGE = "SAME_EDGE_PIPELINED";
	IDDR d19 (
	.D(ddr[19]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q1(data_hi[19]),
	.Q2(data_lo[19]));
endmodule

// macexp DDR_OUT 6
// macexp $size 20
// macexp $instance
// macexp clk
// macexp data_hi
// macexp data_lo
// macexp ddr

module ddr_out_20 ( clk, data_hi, data_lo, ddr );
	// synthesis attribute keep_hierarchy ddr_out_20 "true";
	input clk;
	input [19:0] data_hi;
	input [19:0] data_lo;
	output [19:0] ddr;
	defparam d0.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d0 (
	.D1(data_hi[0]),
	.D2(data_lo[0]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[0]));
	defparam d1.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d1 (
	.D1(data_hi[1]),
	.D2(data_lo[1]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[1]));
	defparam d2.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d2 (
	.D1(data_hi[2]),
	.D2(data_lo[2]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[2]));
	defparam d3.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d3 (
	.D1(data_hi[3]),
	.D2(data_lo[3]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[3]));
	defparam d4.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d4 (
	.D1(data_hi[4]),
	.D2(data_lo[4]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[4]));
	defparam d5.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d5 (
	.D1(data_hi[5]),
	.D2(data_lo[5]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[5]));
	defparam d6.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d6 (
	.D1(data_hi[6]),
	.D2(data_lo[6]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[6]));
	defparam d7.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d7 (
	.D1(data_hi[7]),
	.D2(data_lo[7]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[7]));
	defparam d8.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d8 (
	.D1(data_hi[8]),
	.D2(data_lo[8]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[8]));
	defparam d9.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d9 (
	.D1(data_hi[9]),
	.D2(data_lo[9]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[9]));
	defparam d10.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d10 (
	.D1(data_hi[10]),
	.D2(data_lo[10]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[10]));
	defparam d11.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d11 (
	.D1(data_hi[11]),
	.D2(data_lo[11]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[11]));
	defparam d12.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d12 (
	.D1(data_hi[12]),
	.D2(data_lo[12]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[12]));
	defparam d13.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d13 (
	.D1(data_hi[13]),
	.D2(data_lo[13]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[13]));
	defparam d14.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d14 (
	.D1(data_hi[14]),
	.D2(data_lo[14]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[14]));
	defparam d15.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d15 (
	.D1(data_hi[15]),
	.D2(data_lo[15]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[15]));
	defparam d16.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d16 (
	.D1(data_hi[16]),
	.D2(data_lo[16]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[16]));
	defparam d17.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d17 (
	.D1(data_hi[17]),
	.D2(data_lo[17]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[17]));
	defparam d18.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d18 (
	.D1(data_hi[18]),
	.D2(data_lo[18]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[18]));
	defparam d19.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d19 (
	.D1(data_hi[19]),
	.D2(data_lo[19]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[19]));
endmodule

// macexp DFF_KEEP 5
// macexp $size 28
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_28 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_28 "true";
	// synthesis attribute equivalent_register_removal dff_keep_28 "no";
	// synthesis attribute shift_extract dff_keep_28 "no";
	// synthesis attribute shreg_extract dff_keep_28 "no";
	input clk;
	input [27:0] d;
	// synthesis attribute keep q "true";
	output [27:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
	(* S = "TRUE" *)
	FD q_9 (
	.Q(q[9]),
	.C(clk),
	.D(d[9])
	);
	(* S = "TRUE" *)
	FD q_10 (
	.Q(q[10]),
	.C(clk),
	.D(d[10])
	);
	(* S = "TRUE" *)
	FD q_11 (
	.Q(q[11]),
	.C(clk),
	.D(d[11])
	);
	(* S = "TRUE" *)
	FD q_12 (
	.Q(q[12]),
	.C(clk),
	.D(d[12])
	);
	(* S = "TRUE" *)
	FD q_13 (
	.Q(q[13]),
	.C(clk),
	.D(d[13])
	);
	(* S = "TRUE" *)
	FD q_14 (
	.Q(q[14]),
	.C(clk),
	.D(d[14])
	);
	(* S = "TRUE" *)
	FD q_15 (
	.Q(q[15]),
	.C(clk),
	.D(d[15])
	);
	(* S = "TRUE" *)
	FD q_16 (
	.Q(q[16]),
	.C(clk),
	.D(d[16])
	);
	(* S = "TRUE" *)
	FD q_17 (
	.Q(q[17]),
	.C(clk),
	.D(d[17])
	);
	(* S = "TRUE" *)
	FD q_18 (
	.Q(q[18]),
	.C(clk),
	.D(d[18])
	);
	(* S = "TRUE" *)
	FD q_19 (
	.Q(q[19]),
	.C(clk),
	.D(d[19])
	);
	(* S = "TRUE" *)
	FD q_20 (
	.Q(q[20]),
	.C(clk),
	.D(d[20])
	);
	(* S = "TRUE" *)
	FD q_21 (
	.Q(q[21]),
	.C(clk),
	.D(d[21])
	);
	(* S = "TRUE" *)
	FD q_22 (
	.Q(q[22]),
	.C(clk),
	.D(d[22])
	);
	(* S = "TRUE" *)
	FD q_23 (
	.Q(q[23]),
	.C(clk),
	.D(d[23])
	);
	(* S = "TRUE" *)
	FD q_24 (
	.Q(q[24]),
	.C(clk),
	.D(d[24])
	);
	(* S = "TRUE" *)
	FD q_25 (
	.Q(q[25]),
	.C(clk),
	.D(d[25])
	);
	(* S = "TRUE" *)
	FD q_26 (
	.Q(q[26]),
	.C(clk),
	.D(d[26])
	);
	(* S = "TRUE" *)
	FD q_27 (
	.Q(q[27]),
	.C(clk),
	.D(d[27])
	);
endmodule

// macexp BIDI_IO 6
// macexp $size 18
// macexp $instance
// macexp oe_
// macexp odata
// macexp idata
// macexp data

module bidi_io_18 ( oe_, odata, idata, data );
	// synthesis attribute keep_hierarchy bidi_io_18 "true";
	input [17:0] oe_;
	input [17:0] odata;
	output [17:0] idata;
	inout [17:0] data;
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf0 (.I(odata[0]), .T(oe_[0]), .O(idata[0]), .IO(data[0]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf1 (.I(odata[1]), .T(oe_[1]), .O(idata[1]), .IO(data[1]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf2 (.I(odata[2]), .T(oe_[2]), .O(idata[2]), .IO(data[2]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf3 (.I(odata[3]), .T(oe_[3]), .O(idata[3]), .IO(data[3]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf4 (.I(odata[4]), .T(oe_[4]), .O(idata[4]), .IO(data[4]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf5 (.I(odata[5]), .T(oe_[5]), .O(idata[5]), .IO(data[5]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf6 (.I(odata[6]), .T(oe_[6]), .O(idata[6]), .IO(data[6]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf7 (.I(odata[7]), .T(oe_[7]), .O(idata[7]), .IO(data[7]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf8 (.I(odata[8]), .T(oe_[8]), .O(idata[8]), .IO(data[8]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf9 (.I(odata[9]), .T(oe_[9]), .O(idata[9]), .IO(data[9]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf10 (.I(odata[10]), .T(oe_[10]), .O(idata[10]), .IO(data[10]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf11 (.I(odata[11]), .T(oe_[11]), .O(idata[11]), .IO(data[11]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf12 (.I(odata[12]), .T(oe_[12]), .O(idata[12]), .IO(data[12]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf13 (.I(odata[13]), .T(oe_[13]), .O(idata[13]), .IO(data[13]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf14 (.I(odata[14]), .T(oe_[14]), .O(idata[14]), .IO(data[14]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf15 (.I(odata[15]), .T(oe_[15]), .O(idata[15]), .IO(data[15]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf16 (.I(odata[16]), .T(oe_[16]), .O(idata[16]), .IO(data[16]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf17 (.I(odata[17]), .T(oe_[17]), .O(idata[17]), .IO(data[17]));
endmodule

// macexp BIDI_IO 6
// macexp $size 10
// macexp $instance
// macexp oe_
// macexp odata
// macexp idata
// macexp data

module bidi_io_10 ( oe_, odata, idata, data );
	// synthesis attribute keep_hierarchy bidi_io_10 "true";
	input [9:0] oe_;
	input [9:0] odata;
	output [9:0] idata;
	inout [9:0] data;
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf0 (.I(odata[0]), .T(oe_[0]), .O(idata[0]), .IO(data[0]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf1 (.I(odata[1]), .T(oe_[1]), .O(idata[1]), .IO(data[1]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf2 (.I(odata[2]), .T(oe_[2]), .O(idata[2]), .IO(data[2]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf3 (.I(odata[3]), .T(oe_[3]), .O(idata[3]), .IO(data[3]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf4 (.I(odata[4]), .T(oe_[4]), .O(idata[4]), .IO(data[4]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf5 (.I(odata[5]), .T(oe_[5]), .O(idata[5]), .IO(data[5]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf6 (.I(odata[6]), .T(oe_[6]), .O(idata[6]), .IO(data[6]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf7 (.I(odata[7]), .T(oe_[7]), .O(idata[7]), .IO(data[7]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf8 (.I(odata[8]), .T(oe_[8]), .O(idata[8]), .IO(data[8]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf9 (.I(odata[9]), .T(oe_[9]), .O(idata[9]), .IO(data[9]));
endmodule

// macexp DFF_KEEP 5
// macexp $size 34
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_34 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_34 "true";
	// synthesis attribute equivalent_register_removal dff_keep_34 "no";
	// synthesis attribute shift_extract dff_keep_34 "no";
	// synthesis attribute shreg_extract dff_keep_34 "no";
	input clk;
	input [33:0] d;
	// synthesis attribute keep q "true";
	output [33:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
	(* S = "TRUE" *)
	FD q_9 (
	.Q(q[9]),
	.C(clk),
	.D(d[9])
	);
	(* S = "TRUE" *)
	FD q_10 (
	.Q(q[10]),
	.C(clk),
	.D(d[10])
	);
	(* S = "TRUE" *)
	FD q_11 (
	.Q(q[11]),
	.C(clk),
	.D(d[11])
	);
	(* S = "TRUE" *)
	FD q_12 (
	.Q(q[12]),
	.C(clk),
	.D(d[12])
	);
	(* S = "TRUE" *)
	FD q_13 (
	.Q(q[13]),
	.C(clk),
	.D(d[13])
	);
	(* S = "TRUE" *)
	FD q_14 (
	.Q(q[14]),
	.C(clk),
	.D(d[14])
	);
	(* S = "TRUE" *)
	FD q_15 (
	.Q(q[15]),
	.C(clk),
	.D(d[15])
	);
	(* S = "TRUE" *)
	FD q_16 (
	.Q(q[16]),
	.C(clk),
	.D(d[16])
	);
	(* S = "TRUE" *)
	FD q_17 (
	.Q(q[17]),
	.C(clk),
	.D(d[17])
	);
	(* S = "TRUE" *)
	FD q_18 (
	.Q(q[18]),
	.C(clk),
	.D(d[18])
	);
	(* S = "TRUE" *)
	FD q_19 (
	.Q(q[19]),
	.C(clk),
	.D(d[19])
	);
	(* S = "TRUE" *)
	FD q_20 (
	.Q(q[20]),
	.C(clk),
	.D(d[20])
	);
	(* S = "TRUE" *)
	FD q_21 (
	.Q(q[21]),
	.C(clk),
	.D(d[21])
	);
	(* S = "TRUE" *)
	FD q_22 (
	.Q(q[22]),
	.C(clk),
	.D(d[22])
	);
	(* S = "TRUE" *)
	FD q_23 (
	.Q(q[23]),
	.C(clk),
	.D(d[23])
	);
	(* S = "TRUE" *)
	FD q_24 (
	.Q(q[24]),
	.C(clk),
	.D(d[24])
	);
	(* S = "TRUE" *)
	FD q_25 (
	.Q(q[25]),
	.C(clk),
	.D(d[25])
	);
	(* S = "TRUE" *)
	FD q_26 (
	.Q(q[26]),
	.C(clk),
	.D(d[26])
	);
	(* S = "TRUE" *)
	FD q_27 (
	.Q(q[27]),
	.C(clk),
	.D(d[27])
	);
	(* S = "TRUE" *)
	FD q_28 (
	.Q(q[28]),
	.C(clk),
	.D(d[28])
	);
	(* S = "TRUE" *)
	FD q_29 (
	.Q(q[29]),
	.C(clk),
	.D(d[29])
	);
	(* S = "TRUE" *)
	FD q_30 (
	.Q(q[30]),
	.C(clk),
	.D(d[30])
	);
	(* S = "TRUE" *)
	FD q_31 (
	.Q(q[31]),
	.C(clk),
	.D(d[31])
	);
	(* S = "TRUE" *)
	FD q_32 (
	.Q(q[32]),
	.C(clk),
	.D(d[32])
	);
	(* S = "TRUE" *)
	FD q_33 (
	.Q(q[33]),
	.C(clk),
	.D(d[33])
	);
endmodule

// macexp DDR_OUT 6
// macexp $size 32
// macexp $instance
// macexp clk
// macexp data_hi
// macexp data_lo
// macexp ddr

module ddr_out_32 ( clk, data_hi, data_lo, ddr );
	// synthesis attribute keep_hierarchy ddr_out_32 "true";
	input clk;
	input [31:0] data_hi;
	input [31:0] data_lo;
	output [31:0] ddr;
	defparam d0.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d0 (
	.D1(data_hi[0]),
	.D2(data_lo[0]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[0]));
	defparam d1.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d1 (
	.D1(data_hi[1]),
	.D2(data_lo[1]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[1]));
	defparam d2.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d2 (
	.D1(data_hi[2]),
	.D2(data_lo[2]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[2]));
	defparam d3.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d3 (
	.D1(data_hi[3]),
	.D2(data_lo[3]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[3]));
	defparam d4.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d4 (
	.D1(data_hi[4]),
	.D2(data_lo[4]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[4]));
	defparam d5.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d5 (
	.D1(data_hi[5]),
	.D2(data_lo[5]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[5]));
	defparam d6.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d6 (
	.D1(data_hi[6]),
	.D2(data_lo[6]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[6]));
	defparam d7.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d7 (
	.D1(data_hi[7]),
	.D2(data_lo[7]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[7]));
	defparam d8.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d8 (
	.D1(data_hi[8]),
	.D2(data_lo[8]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[8]));
	defparam d9.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d9 (
	.D1(data_hi[9]),
	.D2(data_lo[9]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[9]));
	defparam d10.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d10 (
	.D1(data_hi[10]),
	.D2(data_lo[10]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[10]));
	defparam d11.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d11 (
	.D1(data_hi[11]),
	.D2(data_lo[11]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[11]));
	defparam d12.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d12 (
	.D1(data_hi[12]),
	.D2(data_lo[12]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[12]));
	defparam d13.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d13 (
	.D1(data_hi[13]),
	.D2(data_lo[13]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[13]));
	defparam d14.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d14 (
	.D1(data_hi[14]),
	.D2(data_lo[14]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[14]));
	defparam d15.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d15 (
	.D1(data_hi[15]),
	.D2(data_lo[15]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[15]));
	defparam d16.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d16 (
	.D1(data_hi[16]),
	.D2(data_lo[16]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[16]));
	defparam d17.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d17 (
	.D1(data_hi[17]),
	.D2(data_lo[17]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[17]));
	defparam d18.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d18 (
	.D1(data_hi[18]),
	.D2(data_lo[18]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[18]));
	defparam d19.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d19 (
	.D1(data_hi[19]),
	.D2(data_lo[19]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[19]));
	defparam d20.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d20 (
	.D1(data_hi[20]),
	.D2(data_lo[20]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[20]));
	defparam d21.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d21 (
	.D1(data_hi[21]),
	.D2(data_lo[21]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[21]));
	defparam d22.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d22 (
	.D1(data_hi[22]),
	.D2(data_lo[22]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[22]));
	defparam d23.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d23 (
	.D1(data_hi[23]),
	.D2(data_lo[23]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[23]));
	defparam d24.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d24 (
	.D1(data_hi[24]),
	.D2(data_lo[24]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[24]));
	defparam d25.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d25 (
	.D1(data_hi[25]),
	.D2(data_lo[25]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[25]));
	defparam d26.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d26 (
	.D1(data_hi[26]),
	.D2(data_lo[26]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[26]));
	defparam d27.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d27 (
	.D1(data_hi[27]),
	.D2(data_lo[27]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[27]));
	defparam d28.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d28 (
	.D1(data_hi[28]),
	.D2(data_lo[28]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[28]));
	defparam d29.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d29 (
	.D1(data_hi[29]),
	.D2(data_lo[29]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[29]));
	defparam d30.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d30 (
	.D1(data_hi[30]),
	.D2(data_lo[30]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[30]));
	defparam d31.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d31 (
	.D1(data_hi[31]),
	.D2(data_lo[31]),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr[31]));
endmodule

// macexp DDR_OUT 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp data_hi
// macexp data_lo
// macexp ddr

module ddr_out_1 ( clk, data_hi, data_lo, ddr );
	// synthesis attribute keep_hierarchy ddr_out_1 "true";
	input clk;
	input data_hi;
	input data_lo;
	output ddr;
	defparam d0.DDR_CLK_EDGE = "SAME_EDGE";
	ODDR d0 (
	.D1(data_hi),
	.D2(data_lo),
	.C(clk),
	.CE(1'b1),
	.S(1'b0),
	.R(1'b0),
	.Q(ddr));
endmodule

// macexp BIDI_IO 6
// macexp $size 32
// macexp $instance
// macexp oe_
// macexp odata
// macexp idata
// macexp data

module bidi_io_32 ( oe_, odata, idata, data );
	// synthesis attribute keep_hierarchy bidi_io_32 "true";
	input [31:0] oe_;
	input [31:0] odata;
	output [31:0] idata;
	inout [31:0] data;
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf0 (.I(odata[0]), .T(oe_[0]), .O(idata[0]), .IO(data[0]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf1 (.I(odata[1]), .T(oe_[1]), .O(idata[1]), .IO(data[1]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf2 (.I(odata[2]), .T(oe_[2]), .O(idata[2]), .IO(data[2]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf3 (.I(odata[3]), .T(oe_[3]), .O(idata[3]), .IO(data[3]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf4 (.I(odata[4]), .T(oe_[4]), .O(idata[4]), .IO(data[4]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf5 (.I(odata[5]), .T(oe_[5]), .O(idata[5]), .IO(data[5]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf6 (.I(odata[6]), .T(oe_[6]), .O(idata[6]), .IO(data[6]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf7 (.I(odata[7]), .T(oe_[7]), .O(idata[7]), .IO(data[7]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf8 (.I(odata[8]), .T(oe_[8]), .O(idata[8]), .IO(data[8]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf9 (.I(odata[9]), .T(oe_[9]), .O(idata[9]), .IO(data[9]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf10 (.I(odata[10]), .T(oe_[10]), .O(idata[10]), .IO(data[10]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf11 (.I(odata[11]), .T(oe_[11]), .O(idata[11]), .IO(data[11]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf12 (.I(odata[12]), .T(oe_[12]), .O(idata[12]), .IO(data[12]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf13 (.I(odata[13]), .T(oe_[13]), .O(idata[13]), .IO(data[13]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf14 (.I(odata[14]), .T(oe_[14]), .O(idata[14]), .IO(data[14]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf15 (.I(odata[15]), .T(oe_[15]), .O(idata[15]), .IO(data[15]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf16 (.I(odata[16]), .T(oe_[16]), .O(idata[16]), .IO(data[16]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf17 (.I(odata[17]), .T(oe_[17]), .O(idata[17]), .IO(data[17]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf18 (.I(odata[18]), .T(oe_[18]), .O(idata[18]), .IO(data[18]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf19 (.I(odata[19]), .T(oe_[19]), .O(idata[19]), .IO(data[19]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf20 (.I(odata[20]), .T(oe_[20]), .O(idata[20]), .IO(data[20]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf21 (.I(odata[21]), .T(oe_[21]), .O(idata[21]), .IO(data[21]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf22 (.I(odata[22]), .T(oe_[22]), .O(idata[22]), .IO(data[22]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf23 (.I(odata[23]), .T(oe_[23]), .O(idata[23]), .IO(data[23]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf24 (.I(odata[24]), .T(oe_[24]), .O(idata[24]), .IO(data[24]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf25 (.I(odata[25]), .T(oe_[25]), .O(idata[25]), .IO(data[25]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf26 (.I(odata[26]), .T(oe_[26]), .O(idata[26]), .IO(data[26]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf27 (.I(odata[27]), .T(oe_[27]), .O(idata[27]), .IO(data[27]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf28 (.I(odata[28]), .T(oe_[28]), .O(idata[28]), .IO(data[28]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf29 (.I(odata[29]), .T(oe_[29]), .O(idata[29]), .IO(data[29]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf30 (.I(odata[30]), .T(oe_[30]), .O(idata[30]), .IO(data[30]));
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf31 (.I(odata[31]), .T(oe_[31]), .O(idata[31]), .IO(data[31]));
endmodule

// macexp BIDI_IO 6
// macexp $size 1
// macexp $instance
// macexp oe_
// macexp odata
// macexp idata
// macexp data

module bidi_io_1 ( oe_, odata, idata, data );
	// synthesis attribute keep_hierarchy bidi_io_1 "true";
	input oe_;
	input odata;
	output idata;
	inout data;
	IOBUF #(.IBUF_LOW_PWR("FALSE")) iobuf0 (.I(odata), .T(oe_), .O(idata), .IO(data));
endmodule

// macexp DFF_KEEP 5
// macexp $size 20
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_20 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_20 "true";
	// synthesis attribute equivalent_register_removal dff_keep_20 "no";
	// synthesis attribute shift_extract dff_keep_20 "no";
	// synthesis attribute shreg_extract dff_keep_20 "no";
	input clk;
	input [19:0] d;
	// synthesis attribute keep q "true";
	output [19:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
	(* S = "TRUE" *)
	FD q_9 (
	.Q(q[9]),
	.C(clk),
	.D(d[9])
	);
	(* S = "TRUE" *)
	FD q_10 (
	.Q(q[10]),
	.C(clk),
	.D(d[10])
	);
	(* S = "TRUE" *)
	FD q_11 (
	.Q(q[11]),
	.C(clk),
	.D(d[11])
	);
	(* S = "TRUE" *)
	FD q_12 (
	.Q(q[12]),
	.C(clk),
	.D(d[12])
	);
	(* S = "TRUE" *)
	FD q_13 (
	.Q(q[13]),
	.C(clk),
	.D(d[13])
	);
	(* S = "TRUE" *)
	FD q_14 (
	.Q(q[14]),
	.C(clk),
	.D(d[14])
	);
	(* S = "TRUE" *)
	FD q_15 (
	.Q(q[15]),
	.C(clk),
	.D(d[15])
	);
	(* S = "TRUE" *)
	FD q_16 (
	.Q(q[16]),
	.C(clk),
	.D(d[16])
	);
	(* S = "TRUE" *)
	FD q_17 (
	.Q(q[17]),
	.C(clk),
	.D(d[17])
	);
	(* S = "TRUE" *)
	FD q_18 (
	.Q(q[18]),
	.C(clk),
	.D(d[18])
	);
	(* S = "TRUE" *)
	FD q_19 (
	.Q(q[19]),
	.C(clk),
	.D(d[19])
	);
endmodule

// macexp DFF_KEEP 5
// macexp $size 40
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_40 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_40 "true";
	// synthesis attribute equivalent_register_removal dff_keep_40 "no";
	// synthesis attribute shift_extract dff_keep_40 "no";
	// synthesis attribute shreg_extract dff_keep_40 "no";
	input clk;
	input [39:0] d;
	// synthesis attribute keep q "true";
	output [39:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
	(* S = "TRUE" *)
	FD q_9 (
	.Q(q[9]),
	.C(clk),
	.D(d[9])
	);
	(* S = "TRUE" *)
	FD q_10 (
	.Q(q[10]),
	.C(clk),
	.D(d[10])
	);
	(* S = "TRUE" *)
	FD q_11 (
	.Q(q[11]),
	.C(clk),
	.D(d[11])
	);
	(* S = "TRUE" *)
	FD q_12 (
	.Q(q[12]),
	.C(clk),
	.D(d[12])
	);
	(* S = "TRUE" *)
	FD q_13 (
	.Q(q[13]),
	.C(clk),
	.D(d[13])
	);
	(* S = "TRUE" *)
	FD q_14 (
	.Q(q[14]),
	.C(clk),
	.D(d[14])
	);
	(* S = "TRUE" *)
	FD q_15 (
	.Q(q[15]),
	.C(clk),
	.D(d[15])
	);
	(* S = "TRUE" *)
	FD q_16 (
	.Q(q[16]),
	.C(clk),
	.D(d[16])
	);
	(* S = "TRUE" *)
	FD q_17 (
	.Q(q[17]),
	.C(clk),
	.D(d[17])
	);
	(* S = "TRUE" *)
	FD q_18 (
	.Q(q[18]),
	.C(clk),
	.D(d[18])
	);
	(* S = "TRUE" *)
	FD q_19 (
	.Q(q[19]),
	.C(clk),
	.D(d[19])
	);
	(* S = "TRUE" *)
	FD q_20 (
	.Q(q[20]),
	.C(clk),
	.D(d[20])
	);
	(* S = "TRUE" *)
	FD q_21 (
	.Q(q[21]),
	.C(clk),
	.D(d[21])
	);
	(* S = "TRUE" *)
	FD q_22 (
	.Q(q[22]),
	.C(clk),
	.D(d[22])
	);
	(* S = "TRUE" *)
	FD q_23 (
	.Q(q[23]),
	.C(clk),
	.D(d[23])
	);
	(* S = "TRUE" *)
	FD q_24 (
	.Q(q[24]),
	.C(clk),
	.D(d[24])
	);
	(* S = "TRUE" *)
	FD q_25 (
	.Q(q[25]),
	.C(clk),
	.D(d[25])
	);
	(* S = "TRUE" *)
	FD q_26 (
	.Q(q[26]),
	.C(clk),
	.D(d[26])
	);
	(* S = "TRUE" *)
	FD q_27 (
	.Q(q[27]),
	.C(clk),
	.D(d[27])
	);
	(* S = "TRUE" *)
	FD q_28 (
	.Q(q[28]),
	.C(clk),
	.D(d[28])
	);
	(* S = "TRUE" *)
	FD q_29 (
	.Q(q[29]),
	.C(clk),
	.D(d[29])
	);
	(* S = "TRUE" *)
	FD q_30 (
	.Q(q[30]),
	.C(clk),
	.D(d[30])
	);
	(* S = "TRUE" *)
	FD q_31 (
	.Q(q[31]),
	.C(clk),
	.D(d[31])
	);
	(* S = "TRUE" *)
	FD q_32 (
	.Q(q[32]),
	.C(clk),
	.D(d[32])
	);
	(* S = "TRUE" *)
	FD q_33 (
	.Q(q[33]),
	.C(clk),
	.D(d[33])
	);
	(* S = "TRUE" *)
	FD q_34 (
	.Q(q[34]),
	.C(clk),
	.D(d[34])
	);
	(* S = "TRUE" *)
	FD q_35 (
	.Q(q[35]),
	.C(clk),
	.D(d[35])
	);
	(* S = "TRUE" *)
	FD q_36 (
	.Q(q[36]),
	.C(clk),
	.D(d[36])
	);
	(* S = "TRUE" *)
	FD q_37 (
	.Q(q[37]),
	.C(clk),
	.D(d[37])
	);
	(* S = "TRUE" *)
	FD q_38 (
	.Q(q[38]),
	.C(clk),
	.D(d[38])
	);
	(* S = "TRUE" *)
	FD q_39 (
	.Q(q[39]),
	.C(clk),
	.D(d[39])
	);
endmodule

// macexp DFF_KEEP 5
// macexp $size 80
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_80 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_80 "true";
	// synthesis attribute equivalent_register_removal dff_keep_80 "no";
	// synthesis attribute shift_extract dff_keep_80 "no";
	// synthesis attribute shreg_extract dff_keep_80 "no";
	input clk;
	input [79:0] d;
	// synthesis attribute keep q "true";
	output [79:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
	(* S = "TRUE" *)
	FD q_9 (
	.Q(q[9]),
	.C(clk),
	.D(d[9])
	);
	(* S = "TRUE" *)
	FD q_10 (
	.Q(q[10]),
	.C(clk),
	.D(d[10])
	);
	(* S = "TRUE" *)
	FD q_11 (
	.Q(q[11]),
	.C(clk),
	.D(d[11])
	);
	(* S = "TRUE" *)
	FD q_12 (
	.Q(q[12]),
	.C(clk),
	.D(d[12])
	);
	(* S = "TRUE" *)
	FD q_13 (
	.Q(q[13]),
	.C(clk),
	.D(d[13])
	);
	(* S = "TRUE" *)
	FD q_14 (
	.Q(q[14]),
	.C(clk),
	.D(d[14])
	);
	(* S = "TRUE" *)
	FD q_15 (
	.Q(q[15]),
	.C(clk),
	.D(d[15])
	);
	(* S = "TRUE" *)
	FD q_16 (
	.Q(q[16]),
	.C(clk),
	.D(d[16])
	);
	(* S = "TRUE" *)
	FD q_17 (
	.Q(q[17]),
	.C(clk),
	.D(d[17])
	);
	(* S = "TRUE" *)
	FD q_18 (
	.Q(q[18]),
	.C(clk),
	.D(d[18])
	);
	(* S = "TRUE" *)
	FD q_19 (
	.Q(q[19]),
	.C(clk),
	.D(d[19])
	);
	(* S = "TRUE" *)
	FD q_20 (
	.Q(q[20]),
	.C(clk),
	.D(d[20])
	);
	(* S = "TRUE" *)
	FD q_21 (
	.Q(q[21]),
	.C(clk),
	.D(d[21])
	);
	(* S = "TRUE" *)
	FD q_22 (
	.Q(q[22]),
	.C(clk),
	.D(d[22])
	);
	(* S = "TRUE" *)
	FD q_23 (
	.Q(q[23]),
	.C(clk),
	.D(d[23])
	);
	(* S = "TRUE" *)
	FD q_24 (
	.Q(q[24]),
	.C(clk),
	.D(d[24])
	);
	(* S = "TRUE" *)
	FD q_25 (
	.Q(q[25]),
	.C(clk),
	.D(d[25])
	);
	(* S = "TRUE" *)
	FD q_26 (
	.Q(q[26]),
	.C(clk),
	.D(d[26])
	);
	(* S = "TRUE" *)
	FD q_27 (
	.Q(q[27]),
	.C(clk),
	.D(d[27])
	);
	(* S = "TRUE" *)
	FD q_28 (
	.Q(q[28]),
	.C(clk),
	.D(d[28])
	);
	(* S = "TRUE" *)
	FD q_29 (
	.Q(q[29]),
	.C(clk),
	.D(d[29])
	);
	(* S = "TRUE" *)
	FD q_30 (
	.Q(q[30]),
	.C(clk),
	.D(d[30])
	);
	(* S = "TRUE" *)
	FD q_31 (
	.Q(q[31]),
	.C(clk),
	.D(d[31])
	);
	(* S = "TRUE" *)
	FD q_32 (
	.Q(q[32]),
	.C(clk),
	.D(d[32])
	);
	(* S = "TRUE" *)
	FD q_33 (
	.Q(q[33]),
	.C(clk),
	.D(d[33])
	);
	(* S = "TRUE" *)
	FD q_34 (
	.Q(q[34]),
	.C(clk),
	.D(d[34])
	);
	(* S = "TRUE" *)
	FD q_35 (
	.Q(q[35]),
	.C(clk),
	.D(d[35])
	);
	(* S = "TRUE" *)
	FD q_36 (
	.Q(q[36]),
	.C(clk),
	.D(d[36])
	);
	(* S = "TRUE" *)
	FD q_37 (
	.Q(q[37]),
	.C(clk),
	.D(d[37])
	);
	(* S = "TRUE" *)
	FD q_38 (
	.Q(q[38]),
	.C(clk),
	.D(d[38])
	);
	(* S = "TRUE" *)
	FD q_39 (
	.Q(q[39]),
	.C(clk),
	.D(d[39])
	);
	(* S = "TRUE" *)
	FD q_40 (
	.Q(q[40]),
	.C(clk),
	.D(d[40])
	);
	(* S = "TRUE" *)
	FD q_41 (
	.Q(q[41]),
	.C(clk),
	.D(d[41])
	);
	(* S = "TRUE" *)
	FD q_42 (
	.Q(q[42]),
	.C(clk),
	.D(d[42])
	);
	(* S = "TRUE" *)
	FD q_43 (
	.Q(q[43]),
	.C(clk),
	.D(d[43])
	);
	(* S = "TRUE" *)
	FD q_44 (
	.Q(q[44]),
	.C(clk),
	.D(d[44])
	);
	(* S = "TRUE" *)
	FD q_45 (
	.Q(q[45]),
	.C(clk),
	.D(d[45])
	);
	(* S = "TRUE" *)
	FD q_46 (
	.Q(q[46]),
	.C(clk),
	.D(d[46])
	);
	(* S = "TRUE" *)
	FD q_47 (
	.Q(q[47]),
	.C(clk),
	.D(d[47])
	);
	(* S = "TRUE" *)
	FD q_48 (
	.Q(q[48]),
	.C(clk),
	.D(d[48])
	);
	(* S = "TRUE" *)
	FD q_49 (
	.Q(q[49]),
	.C(clk),
	.D(d[49])
	);
	(* S = "TRUE" *)
	FD q_50 (
	.Q(q[50]),
	.C(clk),
	.D(d[50])
	);
	(* S = "TRUE" *)
	FD q_51 (
	.Q(q[51]),
	.C(clk),
	.D(d[51])
	);
	(* S = "TRUE" *)
	FD q_52 (
	.Q(q[52]),
	.C(clk),
	.D(d[52])
	);
	(* S = "TRUE" *)
	FD q_53 (
	.Q(q[53]),
	.C(clk),
	.D(d[53])
	);
	(* S = "TRUE" *)
	FD q_54 (
	.Q(q[54]),
	.C(clk),
	.D(d[54])
	);
	(* S = "TRUE" *)
	FD q_55 (
	.Q(q[55]),
	.C(clk),
	.D(d[55])
	);
	(* S = "TRUE" *)
	FD q_56 (
	.Q(q[56]),
	.C(clk),
	.D(d[56])
	);
	(* S = "TRUE" *)
	FD q_57 (
	.Q(q[57]),
	.C(clk),
	.D(d[57])
	);
	(* S = "TRUE" *)
	FD q_58 (
	.Q(q[58]),
	.C(clk),
	.D(d[58])
	);
	(* S = "TRUE" *)
	FD q_59 (
	.Q(q[59]),
	.C(clk),
	.D(d[59])
	);
	(* S = "TRUE" *)
	FD q_60 (
	.Q(q[60]),
	.C(clk),
	.D(d[60])
	);
	(* S = "TRUE" *)
	FD q_61 (
	.Q(q[61]),
	.C(clk),
	.D(d[61])
	);
	(* S = "TRUE" *)
	FD q_62 (
	.Q(q[62]),
	.C(clk),
	.D(d[62])
	);
	(* S = "TRUE" *)
	FD q_63 (
	.Q(q[63]),
	.C(clk),
	.D(d[63])
	);
	(* S = "TRUE" *)
	FD q_64 (
	.Q(q[64]),
	.C(clk),
	.D(d[64])
	);
	(* S = "TRUE" *)
	FD q_65 (
	.Q(q[65]),
	.C(clk),
	.D(d[65])
	);
	(* S = "TRUE" *)
	FD q_66 (
	.Q(q[66]),
	.C(clk),
	.D(d[66])
	);
	(* S = "TRUE" *)
	FD q_67 (
	.Q(q[67]),
	.C(clk),
	.D(d[67])
	);
	(* S = "TRUE" *)
	FD q_68 (
	.Q(q[68]),
	.C(clk),
	.D(d[68])
	);
	(* S = "TRUE" *)
	FD q_69 (
	.Q(q[69]),
	.C(clk),
	.D(d[69])
	);
	(* S = "TRUE" *)
	FD q_70 (
	.Q(q[70]),
	.C(clk),
	.D(d[70])
	);
	(* S = "TRUE" *)
	FD q_71 (
	.Q(q[71]),
	.C(clk),
	.D(d[71])
	);
	(* S = "TRUE" *)
	FD q_72 (
	.Q(q[72]),
	.C(clk),
	.D(d[72])
	);
	(* S = "TRUE" *)
	FD q_73 (
	.Q(q[73]),
	.C(clk),
	.D(d[73])
	);
	(* S = "TRUE" *)
	FD q_74 (
	.Q(q[74]),
	.C(clk),
	.D(d[74])
	);
	(* S = "TRUE" *)
	FD q_75 (
	.Q(q[75]),
	.C(clk),
	.D(d[75])
	);
	(* S = "TRUE" *)
	FD q_76 (
	.Q(q[76]),
	.C(clk),
	.D(d[76])
	);
	(* S = "TRUE" *)
	FD q_77 (
	.Q(q[77]),
	.C(clk),
	.D(d[77])
	);
	(* S = "TRUE" *)
	FD q_78 (
	.Q(q[78]),
	.C(clk),
	.D(d[78])
	);
	(* S = "TRUE" *)
	FD q_79 (
	.Q(q[79]),
	.C(clk),
	.D(d[79])
	);
endmodule

// macexp ADDER 5
// macexp $size 6
// macexp $instance
// macexp i0
// macexp i1
// macexp s

module adder_6 ( i0, i1, s );
	input [5:0] i0;
	input [5:0] i1;
	output [5:0] s;
	wire [7:0] cig_s;
	reg  [7:0] cig_si;
	reg  [7:0] cig_di;
	wire [7:0] cig_co;
	wire [5:0] si;
	wire [1:0] ci;
	assign si = i0 ^ i1;
	always @ (si or i0) begin
	cig_si = 8'h0;
	cig_di = 8'h0;
	cig_si[5:0] = si;
	cig_di[5:0] = i0;
	end
	assign ci[0] = 1'b0;
	CARRY4 cry0 (
	// Outputs
	.O(cig_s[3:0]),
	.CO(cig_co[3:0]),
	// Inputs
	.S(cig_si[3:0]),
	.DI(cig_di[3:0]),
	.CI(ci[0]),
	.CYINIT(1'b0)
	);
	assign ci[1] = cig_co[3];
	CARRY4 cry1 (
	// Outputs
	.O(cig_s[7:4]),
	.CO(cig_co[7:4]),
	// Inputs
	.S(cig_si[7:4]),
	.DI(cig_di[7:4]),
	.CI(ci[1]),
	.CYINIT(1'b0)
	);
	assign s = cig_s[5:0];
endmodule

// macexp DFF_KEEP 5
// macexp $size 3
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_3 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_3 "true";
	// synthesis attribute equivalent_register_removal dff_keep_3 "no";
	// synthesis attribute shift_extract dff_keep_3 "no";
	// synthesis attribute shreg_extract dff_keep_3 "no";
	input clk;
	input [2:0] d;
	// synthesis attribute keep q "true";
	output [2:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
endmodule

// macexp REGFILE 10
// macexp $depth 8
// macexp $size 12
// macexp $instance
// macexp clk_wr
// macexp wr_en
// macexp wr_addr
// macexp wr_data
// macexp clk_rd
// macexp rd_addr
// macexp rd_data

module regfile_8x12 ( clk_wr, wr_en, wr_addr, wr_data, clk_rd, rd_addr, rd_data );
	// synthesis attribute keep_hierarchy regfile_8x12 "true";
	input clk_wr, clk_rd;
	input wr_en;
	input  [2:0] wr_addr;
	input  [11:0] wr_data;
	input  [2:0] rd_addr;
	output [11:0] rd_data;
	// leda XV2P_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg    [11:0] data [8 - 1:0];
	// leda XV2P_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg	[2:0]    r_rd_addr;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	begin
	$random_init("r_rd_addr", "data");
	end
`endif
	// synopsys translate_on
	always @(posedge clk_wr)
	begin
	if (wr_en) begin
	// synopsys translate_off
	if (wr_addr >= 8) begin
	data[7] <= ~(12'b0);
	data[6] <= ~(12'b0);
	data[5] <= ~(12'b0);
	data[4] <= ~(12'b0);
	data[3] <= ~(12'b0);
	data[2] <= ~(12'b0);
	data[1] <= ~(12'b0);
	data[0] <= ~(12'b0);
	end
	else
	// synopsys translate_on
	data[wr_addr] <= wr_data;
	end
	end
	// leda VER_1_4_4_1 off Do not use multiple clocks in a module
	// leda DFT_006 off 2 clocks in a block
	// leda W389 off 2 clocks in the module
	// leda B_1202 off 2 clocks in this unit detected
	always @(posedge clk_rd)
	r_rd_addr <= rd_addr;
	// leda VER_1_4_4_1 on Do not use multiple clocks in a module
	// leda DFT_006 on 2 clocks in a block
	// leda W389 on 2 clocks in the module
	// leda B_1202 on 2 clocks in this unit detected
	assign rd_data = 
	// synopsys translate_off
	(r_rd_addr >= 8) ? ~(12'b0) :
	// synopsys translate_on
	data[r_rd_addr];
endmodule

// macexp REGFILE 10
// macexp $depth 8
// macexp $size 11
// macexp $instance
// macexp clk_wr
// macexp wr_en
// macexp wr_addr
// macexp wr_data
// macexp clk_rd
// macexp rd_addr
// macexp rd_data

module regfile_8x11 ( clk_wr, wr_en, wr_addr, wr_data, clk_rd, rd_addr, rd_data );
	// synthesis attribute keep_hierarchy regfile_8x11 "true";
	input clk_wr, clk_rd;
	input wr_en;
	input  [2:0] wr_addr;
	input  [10:0] wr_data;
	input  [2:0] rd_addr;
	output [10:0] rd_data;
	// leda XV2P_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg    [10:0] data [8 - 1:0];
	// leda XV2P_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg	[2:0]    r_rd_addr;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	begin
	$random_init("r_rd_addr", "data");
	end
`endif
	// synopsys translate_on
	always @(posedge clk_wr)
	begin
	if (wr_en) begin
	// synopsys translate_off
	if (wr_addr >= 8) begin
	data[7] <= ~(11'b0);
	data[6] <= ~(11'b0);
	data[5] <= ~(11'b0);
	data[4] <= ~(11'b0);
	data[3] <= ~(11'b0);
	data[2] <= ~(11'b0);
	data[1] <= ~(11'b0);
	data[0] <= ~(11'b0);
	end
	else
	// synopsys translate_on
	data[wr_addr] <= wr_data;
	end
	end
	// leda VER_1_4_4_1 off Do not use multiple clocks in a module
	// leda DFT_006 off 2 clocks in a block
	// leda W389 off 2 clocks in the module
	// leda B_1202 off 2 clocks in this unit detected
	always @(posedge clk_rd)
	r_rd_addr <= rd_addr;
	// leda VER_1_4_4_1 on Do not use multiple clocks in a module
	// leda DFT_006 on 2 clocks in a block
	// leda W389 on 2 clocks in the module
	// leda B_1202 on 2 clocks in this unit detected
	assign rd_data = 
	// synopsys translate_off
	(r_rd_addr >= 8) ? ~(11'b0) :
	// synopsys translate_on
	data[r_rd_addr];
endmodule

// macexp DFF_KEEP 5
// macexp $size 9
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_9 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_9 "true";
	// synthesis attribute equivalent_register_removal dff_keep_9 "no";
	// synthesis attribute shift_extract dff_keep_9 "no";
	// synthesis attribute shreg_extract dff_keep_9 "no";
	input clk;
	input [8:0] d;
	// synthesis attribute keep q "true";
	output [8:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
endmodule

// macexp DFF 5
// macexp $size 16
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_16 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_16 "true";
	input clk;
	input [15:0] d;
	output [15:0] q;
	reg [15:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp SYNC_PEDGE 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp pulse

module sync_pedge_1 ( clk, d, pulse );
	// synthesis attribute keep_hierarchy sync_pedge_1 "true";
	// synthesis attribute equivalent_register_removal sync_pedge_1 "no";
	// synthesis attribute register_duplication sync_pedge_1 "no";
	// synthesis attribute shift_extract sync_pedge_1 "no";
	// synthesis attribute shreg_extract sync_pedge_1 "no";
	input clk;
	input d;
	output pulse;
	reg pulse;
	reg q;
	reg c_q;
	// synthesis attribute keep meta1 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta1;
	// synthesis attribute keep meta2 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta2;
	reg c_meta2;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg meta3;
	reg c_meta3;
	reg rnd1, rnd2, in_change;
`endif
	// synopsys translate_on
	// the simulation mode has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles.
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2", "meta3");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 or meta2 or q
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta3
`endif
	// synopsys translate_on
	) begin
	pulse = ~q & meta2;
	c_q = meta2;
	c_meta2 = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	// the logic in front of the flops attempts to be careful not to
	// generate multiple edges into the pulse generator from a single
	// input edge while delaying the output edge by 1, 2 or 3 cycles.
	pulse = ~q & meta3;
	in_change = (d & ~(meta1 | meta2 | meta3)) |
	(~d & (meta1 & meta2 & meta3));
	c_meta2 = meta1;
	c_meta3 = meta2;
	c_q = meta3;
	if (in_change)
	begin
	rnd1 = $random(seed);
	rnd2 = $random(seed);
	c_meta3 = (~in_change & meta2) | (in_change & (d ^ (rnd1 | rnd2)
	));
	c_meta2 = (~in_change & meta1) | (in_change & (d ^ rnd1));
	end
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	meta2 <= c_meta2;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta3 <= c_meta3;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp DFFC_KEEP 6
// macexp $size 3
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_keep_3 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_keep_3 "true";
	// synthesis attribute equivalent_register_removal dffc_keep_3 "no";
	// synthesis attribute shift_extract dffc_keep_3 "no";
	// synthesis attribute shreg_extract dffc_keep_3 "no";
	input clk;
	input reset;
	input [2:0] d;
	// synthesis attribute keep q "true";
	output [2:0] q;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	(* S = "TRUE" *)
	FDR q_0 (
	.Q(q[0]),
	.C(clk),
	.R(reset),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FDR q_1 (
	.Q(q[1]),
	.C(clk),
	.R(reset),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FDR q_2 (
	.Q(q[2]),
	.C(clk),
	.R(reset),
	.D(d[2])
	);
endmodule

// macexp SYNC2 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_1 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_1 "true";
	// synthesis attribute equivalent_register_removal sync2_1 "no";
	// synthesis attribute register_duplication sync2_1 "no";
	// synthesis attribute shift_extract sync2_1 "no";
	// synthesis attribute shreg_extract sync2_1 "no";
	input clk;
	input d;
	output q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ q;
	reg c_q;
	// synthesis attribute keep meta1 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg c_meta2;
	reg meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp REGFILE 10
// macexp $depth 8
// macexp $size 1
// macexp $instance
// macexp clk_wr
// macexp wr_en
// macexp wr_addr
// macexp wr_data
// macexp clk_rd
// macexp rd_addr
// macexp rd_data

module regfile_8x1 ( clk_wr, wr_en, wr_addr, wr_data, clk_rd, rd_addr, rd_data );
	// synthesis attribute keep_hierarchy regfile_8x1 "true";
	input clk_wr, clk_rd;
	input wr_en;
	input  [2:0] wr_addr;
	input                    wr_data;
	input  [2:0] rd_addr;
	output                   rd_data;
	// leda XV2P_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg			     data [8 - 1:0];
	// leda XV2P_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg	[2:0]    r_rd_addr;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	begin
	$random_init("r_rd_addr", "data");
	end
`endif
	// synopsys translate_on
	always @(posedge clk_wr)
	begin
	if (wr_en) begin
	// synopsys translate_off
	if (wr_addr >= 8) begin
	data[7] <= ~(1'b0);
	data[6] <= ~(1'b0);
	data[5] <= ~(1'b0);
	data[4] <= ~(1'b0);
	data[3] <= ~(1'b0);
	data[2] <= ~(1'b0);
	data[1] <= ~(1'b0);
	data[0] <= ~(1'b0);
	end
	else
	// synopsys translate_on
	data[wr_addr] <= wr_data;
	end
	end
	// leda VER_1_4_4_1 off Do not use multiple clocks in a module
	// leda DFT_006 off 2 clocks in a block
	// leda W389 off 2 clocks in the module
	// leda B_1202 off 2 clocks in this unit detected
	always @(posedge clk_rd)
	r_rd_addr <= rd_addr;
	// leda VER_1_4_4_1 on Do not use multiple clocks in a module
	// leda DFT_006 on 2 clocks in a block
	// leda W389 on 2 clocks in the module
	// leda B_1202 on 2 clocks in this unit detected
	assign rd_data = 
	// synopsys translate_off
	(r_rd_addr >= 8) ? ~(1'b0) :
	// synopsys translate_on
	data[r_rd_addr];
endmodule

// macexp DFF_KEEP 5
// macexp $size 5
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_5 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_5 "true";
	// synthesis attribute equivalent_register_removal dff_keep_5 "no";
	// synthesis attribute shift_extract dff_keep_5 "no";
	// synthesis attribute shreg_extract dff_keep_5 "no";
	input clk;
	input [4:0] d;
	// synthesis attribute keep q "true";
	output [4:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
endmodule

// macexp DFFP 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp preset
// macexp d
// macexp q

module dffp_1 ( clk, preset, d, q );
	// synthesis attribute keep_hierarchy dffp_1 "true";
	input clk;
	input preset;
	input d;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: preset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(preset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk or posedge preset) begin
	if (preset)
	q <= ~(1'b0);
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 8
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_8 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_8 "true";
	input clk;
	input reset;
	input [7:0] d;
	output [7:0] q;
	reg [7:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 8'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFSI 7
// macexp $size 9
// macexp $instance
// macexp clk
// macexp reset
// macexp init
// macexp d
// macexp q

module dffsi_9 ( clk, reset, init, d, q );
	// synthesis attribute keep_hierarchy dffsi_9 "true";
	input clk;
	input reset;
	input [8:0] init;
	input [8:0] d;
	output [8:0] q;
	reg [8:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= init;
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 256
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_256 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_256 "true";
	input clk;
	input reset;
	input [255:0] d;
	output [255:0] q;
	reg [255:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 256'b0;
	else
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 68
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_68 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_68 "true";
	input clk;
	input [67:0] d;
	output [67:0] q;
	reg [67:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 66
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_66 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_66 "true";
	input clk;
	input [65:0] d;
	output [65:0] q;
	reg [65:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFR 6
// macexp $size 9
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffr_9 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffr_9 "true";
	input clk;
	input reset;
	input [8:0] d;
	output [8:0] q;
	reg [8:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk or posedge reset) begin
	if (reset)
	q <= 9'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFS 6
// macexp $size 6
// macexp $instance
// macexp clk
// macexp set
// macexp d
// macexp q

module dffs_6 ( clk, set, d, q );
	// synthesis attribute keep_hierarchy dffs_6 "true";
	input clk;
	input set;
	input [5:0] d;
	output [5:0] q;
	reg [5:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (set)
	q <= ~(6'b0);
	else
	q <= d;
	end
endmodule

// macexp DLY100_SEL 5
// macexp $depth 2
// macexp $size 2
// macexp $instance
// macexp i
// macexp o

module dly2_2 ( i, o );
	input [1:0] i;
	output [1:0] o;
	wire [1:0] n0;
	wire [1:0] n1;
	wire [1:0] n2;
	assign n0 = i;
	(* S = "TRUE" *)
	BUF dly00 (.I(n0[0]), .O(n1[0]));
	(* S = "TRUE" *)
	BUF dly01 (.I(n0[1]), .O(n1[1]));
	(* S = "TRUE" *)
	BUF dly10 (.I(n1[0]), .O(n2[0]));
	(* S = "TRUE" *)
	BUF dly11 (.I(n1[1]), .O(n2[1]));
	assign o = n2;
endmodule

// macexp SRL 6
// macexp $depth 4
// macexp $size 64
// macexp $instance
// macexp clk
// macexp d
// macexp q

module srl_4x64 ( clk, d, q );
	// synthesis attribute keep_hierarchy srl_4x64 "true";
	input clk;
	input [63:0] d;
	output [63:0] q;
	parameter V6 = 0;
	// leda XV2_1603 off Instantiated shift register SRL16 detected
	// leda XV2P_1603 off Instantiated shift register SRL16 detected
	// leda XV4_1603 off Instantiated shift register SRL16 detected
	wire [3:0] a;
	assign a = 4'd 2;
	srle_x8 #(.V6(V6)) srl0 (.clk(clk), .ce(1'b1), .d(d[7:0]), .adr0(a), .adr1(a), .adr2(a), .adr3(a), .q(q[7:0]));
	srle_x8 #(.V6(V6)) srl8 (.clk(clk), .ce(1'b1), .d(d[15:8]), .adr0(a), .adr1(a), .adr2(a), .adr3(a), .q(q[15:8]));
	srle_x8 #(.V6(V6)) srl16 (.clk(clk), .ce(1'b1), .d(d[23:16]), .adr0(a), .adr1(a), .adr2(a), .adr3(a), .q(q[23:16]));
	srle_x8 #(.V6(V6)) srl24 (.clk(clk), .ce(1'b1), .d(d[31:24]), .adr0(a), .adr1(a), .adr2(a), .adr3(a), .q(q[31:24]));
	srle_x8 #(.V6(V6)) srl32 (.clk(clk), .ce(1'b1), .d(d[39:32]), .adr0(a), .adr1(a), .adr2(a), .adr3(a), .q(q[39:32]));
	srle_x8 #(.V6(V6)) srl40 (.clk(clk), .ce(1'b1), .d(d[47:40]), .adr0(a), .adr1(a), .adr2(a), .adr3(a), .q(q[47:40]));
	srle_x8 #(.V6(V6)) srl48 (.clk(clk), .ce(1'b1), .d(d[55:48]), .adr0(a), .adr1(a), .adr2(a), .adr3(a), .q(q[55:48]));
	srle_x8 #(.V6(V6)) srl56 (.clk(clk), .ce(1'b1), .d(d[63:56]), .adr0(a), .adr1(a), .adr2(a), .adr3(a), .q(q[63:56]));
	// leda XV2_1603 on Instantiated shift register SRL16 detected
	// leda XV2P_1603 on Instantiated shift register SRL16 detected
	// leda XV4_1603 on Instantiated shift register SRL16 detected
endmodule

// macexp MUX4 8
// macexp $size 8
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp i2
// macexp i3
// macexp o

module mux4_8 ( s, i0, i1, i2, i3, o );
	input  [1:0] s;
	input  [7:0] i0, i1, i2, i3;
	output [7:0] o;
	// synthesis attribute keep_hierarchy mux4_8 "yes";
	defparam m0.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m0 (
	.I0(s[1]),
	.I1(i3[0]),
	.I2(s[0]),
	.I3(i0[0]),
	.I4(i2[0]),
	.I5(i1[0]),
	.O(o[0])
	);
	defparam m1.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m1 (
	.I0(s[1]),
	.I1(i3[1]),
	.I2(s[0]),
	.I3(i0[1]),
	.I4(i2[1]),
	.I5(i1[1]),
	.O(o[1])
	);
	defparam m2.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m2 (
	.I0(s[1]),
	.I1(i3[2]),
	.I2(s[0]),
	.I3(i0[2]),
	.I4(i2[2]),
	.I5(i1[2]),
	.O(o[2])
	);
	defparam m3.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m3 (
	.I0(s[1]),
	.I1(i3[3]),
	.I2(s[0]),
	.I3(i0[3]),
	.I4(i2[3]),
	.I5(i1[3]),
	.O(o[3])
	);
	defparam m4.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m4 (
	.I0(s[1]),
	.I1(i3[4]),
	.I2(s[0]),
	.I3(i0[4]),
	.I4(i2[4]),
	.I5(i1[4]),
	.O(o[4])
	);
	defparam m5.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m5 (
	.I0(s[1]),
	.I1(i3[5]),
	.I2(s[0]),
	.I3(i0[5]),
	.I4(i2[5]),
	.I5(i1[5]),
	.O(o[5])
	);
	defparam m6.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m6 (
	.I0(s[1]),
	.I1(i3[6]),
	.I2(s[0]),
	.I3(i0[6]),
	.I4(i2[6]),
	.I5(i1[6]),
	.O(o[6])
	);
	defparam m7.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m7 (
	.I0(s[1]),
	.I1(i3[7]),
	.I2(s[0]),
	.I3(i0[7]),
	.I4(i2[7]),
	.I5(i1[7]),
	.O(o[7])
	);
endmodule

// macexp DPRAM1R1W_64xXX 8
// macexp $size 8
// macexp $instance
// macexp clk
// macexp wea
// macexp aa
// macexp da
// macexp ab
// macexp dout

module dpram1r1w_64x8 ( clk, wea, aa, da, ab, dout );
	// synthesis attribute keep_hierarchy dpram1r1w_64x8 "true";
	input clk;
	input wea;
	input [5:0] aa;
	input [7:0] da;
	input [5:0] ab;
	output [7:0] dout;
	
	reg   [8:0] c_wrd;
	wire  [8:0] cig_do;
	// leda  FM_2_23 off    -  Non driven output ports or signals _nc10_ detected
	wire  _nc00_;
	// leda  FM_2_23 on    -  Non driven output ports or signals _nc10_ detected
	// leda  FM_2_23 off    -  Non driven output ports or signals _nc10_ detected
	wire  _nc01_;
	// leda  FM_2_23 on    -  Non driven output ports or signals _nc10_ detected
	// leda  FM_2_23 off    -  Non driven output ports or signals _nc10_ detected
	wire  _nc02_;
	// leda  FM_2_23 on    -  Non driven output ports or signals _nc10_ detected
	assign dout = cig_do[7:0];
	always @(da) begin
	c_wrd = 9'b0;
	c_wrd[7:0] = da;
	end
	wire w_0 = 1'b0;
	RAM64M ram64x3_0 (
	// Outputs
	.DOA(cig_do[0]),
	.DOB(cig_do[1]),
	.DOC(cig_do[2]),
	.DOD(_nc00_),
	// Inputs
	.ADDRA(ab),      // rd addr
	.ADDRB(ab),      // rd addr
	.ADDRC(ab),      // rd addr
	.ADDRD(aa),      // wr addr
	.DIA(c_wrd[0]),
	.DIB(c_wrd[1]),
	.DIC(c_wrd[2]),
	.DID(w_0),
	.WCLK(clk),
	.WE(wea)
	);
	RAM64M ram64x3_1 (
	// Outputs
	.DOA(cig_do[3]),
	.DOB(cig_do[4]),
	.DOC(cig_do[5]),
	.DOD(_nc01_),
	// Inputs
	.ADDRA(ab),      // rd addr
	.ADDRB(ab),      // rd addr
	.ADDRC(ab),      // rd addr
	.ADDRD(aa),      // wr addr
	.DIA(c_wrd[3]),
	.DIB(c_wrd[4]),
	.DIC(c_wrd[5]),
	.DID(w_0),
	.WCLK(clk),
	.WE(wea)
	);
	RAM64M ram64x3_2 (
	// Outputs
	.DOA(cig_do[6]),
	.DOB(cig_do[7]),
	.DOC(cig_do[8]),
	.DOD(_nc02_),
	// Inputs
	.ADDRA(ab),      // rd addr
	.ADDRB(ab),      // rd addr
	.ADDRC(ab),      // rd addr
	.ADDRD(aa),      // wr addr
	.DIA(c_wrd[6]),
	.DIB(c_wrd[7]),
	.DIC(c_wrd[8]),
	.DID(w_0),
	.WCLK(clk),
	.WE(wea)
	);
endmodule

// macexp SRL 6
// macexp $depth 2
// macexp $size 8
// macexp $instance
// macexp clk
// macexp d
// macexp q

module srl_2x8 ( clk, d, q );
	// synthesis attribute keep_hierarchy srl_2x8 "true";
	input clk;
	input [7:0] d;
	output [7:0] q;
	parameter V6 = 0;
	// leda XV2_1603 off Instantiated shift register SRL16 detected
	// leda XV2P_1603 off Instantiated shift register SRL16 detected
	// leda XV4_1603 off Instantiated shift register SRL16 detected
	wire [3:0] a;
	assign a = 4'd 0;
	srle_x8 #(.V6(V6)) srl0 (.clk(clk), .ce(1'b1), .d(d[7:0]), .adr0(a), .adr1(a), .adr2(a), .adr3(a), .q(q[7:0]));
	// leda XV2_1603 on Instantiated shift register SRL16 detected
	// leda XV2P_1603 on Instantiated shift register SRL16 detected
	// leda XV4_1603 on Instantiated shift register SRL16 detected
endmodule

// macexp PEXT_P2 5
// macexp $instance
// macexp $cycles 8
// macexp clk
// macexp d
// macexp q

module pext_p2_8 ( clk, d, q );
	// synthesis attribute keep_hierarchy pext_p2_8 "true";
	input clk;
	input d;
	output q;
	reg q;
	reg c_q;
	reg [2:0] r_cnt;
	reg [2:0] c_cnt;
	reg [2:0] cig_zerocnt;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial begin
	$random_init("q", "r_cnt");
	end
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	r_cnt <= // synthesis translate_off
	(^c_cnt === 1'bx) ? $random :
	// synthesis translate_on
	c_cnt;
	q <= c_q;
	end
	always @ (d or q or r_cnt) begin
	cig_zerocnt = 3'b0;
	c_cnt = d ? ~cig_zerocnt : {r_cnt - ((|r_cnt) ? 3'b1 : 3'b0)};
	c_q = d | (|r_cnt);
	end
endmodule

// macexp DLY100_SEL 5
// macexp $depth 1
// macexp $size 8
// macexp $instance
// macexp i
// macexp o

module dly1_8 ( i, o );
	input [7:0] i;
	output [7:0] o;
	(* S = "TRUE" *)
	BUF dly0 (.I(i[0]), .O(o[0]));
	(* S = "TRUE" *)
	BUF dly1 (.I(i[1]), .O(o[1]));
	(* S = "TRUE" *)
	BUF dly2 (.I(i[2]), .O(o[2]));
	(* S = "TRUE" *)
	BUF dly3 (.I(i[3]), .O(o[3]));
	(* S = "TRUE" *)
	BUF dly4 (.I(i[4]), .O(o[4]));
	(* S = "TRUE" *)
	BUF dly5 (.I(i[5]), .O(o[5]));
	(* S = "TRUE" *)
	BUF dly6 (.I(i[6]), .O(o[6]));
	(* S = "TRUE" *)
	BUF dly7 (.I(i[7]), .O(o[7]));
endmodule

// macexp DLY100_SEL 5
// macexp $depth 1
// macexp $size 17
// macexp $instance
// macexp i
// macexp o

module dly1_17 ( i, o );
	input [16:0] i;
	output [16:0] o;
	(* S = "TRUE" *)
	BUF dly0 (.I(i[0]), .O(o[0]));
	(* S = "TRUE" *)
	BUF dly1 (.I(i[1]), .O(o[1]));
	(* S = "TRUE" *)
	BUF dly2 (.I(i[2]), .O(o[2]));
	(* S = "TRUE" *)
	BUF dly3 (.I(i[3]), .O(o[3]));
	(* S = "TRUE" *)
	BUF dly4 (.I(i[4]), .O(o[4]));
	(* S = "TRUE" *)
	BUF dly5 (.I(i[5]), .O(o[5]));
	(* S = "TRUE" *)
	BUF dly6 (.I(i[6]), .O(o[6]));
	(* S = "TRUE" *)
	BUF dly7 (.I(i[7]), .O(o[7]));
	(* S = "TRUE" *)
	BUF dly8 (.I(i[8]), .O(o[8]));
	(* S = "TRUE" *)
	BUF dly9 (.I(i[9]), .O(o[9]));
	(* S = "TRUE" *)
	BUF dly10 (.I(i[10]), .O(o[10]));
	(* S = "TRUE" *)
	BUF dly11 (.I(i[11]), .O(o[11]));
	(* S = "TRUE" *)
	BUF dly12 (.I(i[12]), .O(o[12]));
	(* S = "TRUE" *)
	BUF dly13 (.I(i[13]), .O(o[13]));
	(* S = "TRUE" *)
	BUF dly14 (.I(i[14]), .O(o[14]));
	(* S = "TRUE" *)
	BUF dly15 (.I(i[15]), .O(o[15]));
	(* S = "TRUE" *)
	BUF dly16 (.I(i[16]), .O(o[16]));
endmodule

// macexp DFFC 6
// macexp $size 5
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_5 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_5 "true";
	input clk;
	input reset;
	input [4:0] d;
	output [4:0] q;
	reg [4:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 5'b0;
	else
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 7
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_7 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_7 "true";
	input clk;
	input [6:0] d;
	output [6:0] q;
	reg [6:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DLY100_SEL 5
// macexp $depth 1
// macexp $size 1
// macexp $instance
// macexp i
// macexp o

module dly1_1 ( i, o );
	input i;
	output o;
	(* S = "TRUE" *)
	BUF dly (.I(i), .O(o));
endmodule

// macexp DLY100_SEL 5
// macexp $depth 2
// macexp $size 1
// macexp $instance
// macexp i
// macexp o

module dly2_1 ( i, o );
	input i;
	output o;
	wire n0;
	wire n1;
	wire n2;
	assign n0 = i;
	(* S = "TRUE" *)
	BUF dly0 (.I(n0), .O(n1));
	(* S = "TRUE" *)
	BUF dly1 (.I(n1), .O(n2));
	assign o = n2;
endmodule

// macexp RDPRAM1RW1R_128xXX 11
// macexp $size 1
// macexp $instance
// macexp clk
// macexp wea
// macexp aa
// macexp da
// macexp lda
// macexp qa
// macexp ab
// macexp ldb
// macexp qb

module rdpram1rw1r_128x1 ( clk, wea, aa, da, lda, qa, ab, ldb, qb );
	// synthesis attribute keep_hierarchy rdpram1rw1r_128x1 "true";
	input clk;
	input wea;
	input [6:0] aa;
	input [0:0] da;
	input       lda;
	output [0:0] qa;
	input [6:0] ab;
	input       ldb;
	output [0:0] qb;
	
	reg  [0:0] qa;
	reg  [0:0] qb;
	wire [0:0] ao;
	wire [0:0] bo;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	begin
	$random_init("qa", "qb");
	end
`endif
	// synopsys translate_on
	// leda VER_2_6_2_1A off Multiple if statements in same always
	always @(posedge clk) begin
	// leda XV2P_1006 off Multiple synchronous resets detected
	// leda XV2P_1007 off Multiple synchronous resets detected
	// leda G_551_1_K off Multiple synchronous resets detected
	// leda B_1416 B_1418 off 2 sync loads
	if (lda)
	qa <= ao;
	if (ldb)
	qb <= bo;
	// leda XV2P_1006 on Multiple synchronous resets detected
	// leda XV2P_1007 on Multiple synchronous resets detected
	// leda G_551_1_K on Multiple synchronous resets detected
	// leda B_1416 B_1418 on 2 sync loads
	end
	// leda VER_2_6_2_1A on Multiple if statements in same always
	RAM128X1D ram128x1_0 (
	// Outputs
	.DPO(bo[0]),
	.SPO(ao[0]),
	// Inputs
	.DPRA(ab),       // rd addr
	.A(aa),          // wr addr
	.D(da[0]),
	.WCLK(clk),
	.WE(wea)
	);
endmodule

// macexp ADDER 5
// macexp $size 8
// macexp $instance
// macexp i0
// macexp i1
// macexp s

module adder_8 ( i0, i1, s );
	input [7:0] i0;
	input [7:0] i1;
	output [7:0] s;
	wire [7:0] cig_s;
	reg  [7:0] cig_si;
	reg  [7:0] cig_di;
	wire [7:0] cig_co;
	wire [7:0] si;
	wire [1:0] ci;
	assign si = i0 ^ i1;
	always @ (si or i0) begin
	cig_si = 8'h0;
	cig_di = 8'h0;
	cig_si[7:0] = si;
	cig_di[7:0] = i0;
	end
	assign ci[0] = 1'b0;
	CARRY4 cry0 (
	// Outputs
	.O(cig_s[3:0]),
	.CO(cig_co[3:0]),
	// Inputs
	.S(cig_si[3:0]),
	.DI(cig_di[3:0]),
	.CI(ci[0]),
	.CYINIT(1'b0)
	);
	assign ci[1] = cig_co[3];
	CARRY4 cry1 (
	// Outputs
	.O(cig_s[7:4]),
	.CO(cig_co[7:4]),
	// Inputs
	.S(cig_si[7:4]),
	.DI(cig_di[7:4]),
	.CI(ci[1]),
	.CYINIT(1'b0)
	);
	assign s = cig_s[7:0];
endmodule

// macexp ADDER 5
// macexp $size 7
// macexp $instance
// macexp i0
// macexp i1
// macexp s

module adder_7 ( i0, i1, s );
	input [6:0] i0;
	input [6:0] i1;
	output [6:0] s;
	wire [7:0] cig_s;
	reg  [7:0] cig_si;
	reg  [7:0] cig_di;
	wire [7:0] cig_co;
	wire [6:0] si;
	wire [1:0] ci;
	assign si = i0 ^ i1;
	always @ (si or i0) begin
	cig_si = 8'h0;
	cig_di = 8'h0;
	cig_si[6:0] = si;
	cig_di[6:0] = i0;
	end
	assign ci[0] = 1'b0;
	CARRY4 cry0 (
	// Outputs
	.O(cig_s[3:0]),
	.CO(cig_co[3:0]),
	// Inputs
	.S(cig_si[3:0]),
	.DI(cig_di[3:0]),
	.CI(ci[0]),
	.CYINIT(1'b0)
	);
	assign ci[1] = cig_co[3];
	CARRY4 cry1 (
	// Outputs
	.O(cig_s[7:4]),
	.CO(cig_co[7:4]),
	// Inputs
	.S(cig_si[7:4]),
	.DI(cig_di[7:4]),
	.CI(ci[1]),
	.CYINIT(1'b0)
	);
	assign s = cig_s[6:0];
endmodule

// macexp MUX4 8
// macexp $size 7
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp i2
// macexp i3
// macexp o

module mux4_7 ( s, i0, i1, i2, i3, o );
	input  [1:0] s;
	input  [6:0] i0, i1, i2, i3;
	output [6:0] o;
	// synthesis attribute keep_hierarchy mux4_7 "yes";
	defparam m0.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m0 (
	.I0(s[1]),
	.I1(i3[0]),
	.I2(s[0]),
	.I3(i0[0]),
	.I4(i2[0]),
	.I5(i1[0]),
	.O(o[0])
	);
	defparam m1.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m1 (
	.I0(s[1]),
	.I1(i3[1]),
	.I2(s[0]),
	.I3(i0[1]),
	.I4(i2[1]),
	.I5(i1[1]),
	.O(o[1])
	);
	defparam m2.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m2 (
	.I0(s[1]),
	.I1(i3[2]),
	.I2(s[0]),
	.I3(i0[2]),
	.I4(i2[2]),
	.I5(i1[2]),
	.O(o[2])
	);
	defparam m3.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m3 (
	.I0(s[1]),
	.I1(i3[3]),
	.I2(s[0]),
	.I3(i0[3]),
	.I4(i2[3]),
	.I5(i1[3]),
	.O(o[3])
	);
	defparam m4.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m4 (
	.I0(s[1]),
	.I1(i3[4]),
	.I2(s[0]),
	.I3(i0[4]),
	.I4(i2[4]),
	.I5(i1[4]),
	.O(o[4])
	);
	defparam m5.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m5 (
	.I0(s[1]),
	.I1(i3[5]),
	.I2(s[0]),
	.I3(i0[5]),
	.I4(i2[5]),
	.I5(i1[5]),
	.O(o[5])
	);
	defparam m6.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m6 (
	.I0(s[1]),
	.I1(i3[6]),
	.I2(s[0]),
	.I3(i0[6]),
	.I4(i2[6]),
	.I5(i1[6]),
	.O(o[6])
	);
endmodule

// macexp MUX4 8
// macexp $size 1
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp i2
// macexp i3
// macexp o

module mux4_1 ( s, i0, i1, i2, i3, o );
	input [1:0] s;
	input i0, i1, i2, i3;
	output o;
	// synthesis attribute keep_hierarchy mux4_1 "yes";
	defparam m0.INIT = 64'hDFDAD5D08F8A8580;
	LUT6 m0 (
	.I0(s[1]),
	.I1(i3),
	.I2(s[0]),
	.I3(i0),
	.I4(i2),
	.I5(i1),
	.O(o)
	);
endmodule

// macexp DLY100_SEL 5
// macexp $depth 1
// macexp $size 2
// macexp $instance
// macexp i
// macexp o

module dly1_2 ( i, o );
	input [1:0] i;
	output [1:0] o;
	(* S = "TRUE" *)
	BUF dly0 (.I(i[0]), .O(o[0]));
	(* S = "TRUE" *)
	BUF dly1 (.I(i[1]), .O(o[1]));
endmodule

// macexp ADDSUB 6
// macexp $size 9
// macexp $instance
// macexp i0
// macexp i1
// macexp s
// macexp sub

module addsub_9 ( i0, i1, s, sub );
	input [8:0] i0;
	input [8:0] i1;
	output [8:0] s;
	input sub;
	wire [11:0] cig_s;
	reg  [11:0] cig_si;
	reg  [11:0] cig_di;
	wire [11:0] cig_co;
	wire [8:0] si;
	wire [2:0] ci;
	wire [2:0] cyinit;
	assign si = i0 ^ (sub ? ~i1 : i1);
	always @ (si or i0) begin
	cig_si = 12'h0;
	cig_di = 12'h0;
	cig_si[8:0] = si;
	cig_di[8:0] = i0;
	end
	assign ci[0] = 1'b0;
	assign cyinit[0] = sub;
	CARRY4 cry0 (
	// Outputs
	.O(cig_s[3:0]),
	.CO(cig_co[3:0]),
	// Inputs
	.S(cig_si[3:0]),
	.DI(cig_di[3:0]),
	.CI(ci[0]),
	.CYINIT(cyinit[0])
	);
	assign ci[1] = cig_co[3];
	assign cyinit[1] = 1'b0;
	CARRY4 cry1 (
	// Outputs
	.O(cig_s[7:4]),
	.CO(cig_co[7:4]),
	// Inputs
	.S(cig_si[7:4]),
	.DI(cig_di[7:4]),
	.CI(ci[1]),
	.CYINIT(cyinit[1])
	);
	assign ci[2] = cig_co[7];
	assign cyinit[2] = 1'b0;
	CARRY4 cry2 (
	// Outputs
	.O(cig_s[11:8]),
	.CO(cig_co[11:8]),
	// Inputs
	.S(cig_si[11:8]),
	.DI(cig_di[11:8]),
	.CI(ci[2]),
	.CYINIT(cyinit[2])
	);
	assign s = cig_s[8:0];
endmodule

// macexp ADDSUB 6
// macexp $size 8
// macexp $instance
// macexp i0
// macexp i1
// macexp s
// macexp sub

module addsub_8 ( i0, i1, s, sub );
	input [7:0] i0;
	input [7:0] i1;
	output [7:0] s;
	input sub;
	wire [7:0] cig_s;
	reg  [7:0] cig_si;
	reg  [7:0] cig_di;
	wire [7:0] cig_co;
	wire [7:0] si;
	wire [1:0] ci;
	wire [1:0] cyinit;
	assign si = i0 ^ (sub ? ~i1 : i1);
	always @ (si or i0) begin
	cig_si = 8'h0;
	cig_di = 8'h0;
	cig_si[7:0] = si;
	cig_di[7:0] = i0;
	end
	assign ci[0] = 1'b0;
	assign cyinit[0] = sub;
	CARRY4 cry0 (
	// Outputs
	.O(cig_s[3:0]),
	.CO(cig_co[3:0]),
	// Inputs
	.S(cig_si[3:0]),
	.DI(cig_di[3:0]),
	.CI(ci[0]),
	.CYINIT(cyinit[0])
	);
	assign ci[1] = cig_co[3];
	assign cyinit[1] = 1'b0;
	CARRY4 cry1 (
	// Outputs
	.O(cig_s[7:4]),
	.CO(cig_co[7:4]),
	// Inputs
	.S(cig_si[7:4]),
	.DI(cig_di[7:4]),
	.CI(ci[1]),
	.CYINIT(cyinit[1])
	);
	assign s = cig_s[7:0];
endmodule

// macexp DLY100_SEL 5
// macexp $depth 1
// macexp $size 64
// macexp $instance
// macexp i
// macexp o

module dly1_64 ( i, o );
	input [63:0] i;
	output [63:0] o;
	(* S = "TRUE" *)
	BUF dly0 (.I(i[0]), .O(o[0]));
	(* S = "TRUE" *)
	BUF dly1 (.I(i[1]), .O(o[1]));
	(* S = "TRUE" *)
	BUF dly2 (.I(i[2]), .O(o[2]));
	(* S = "TRUE" *)
	BUF dly3 (.I(i[3]), .O(o[3]));
	(* S = "TRUE" *)
	BUF dly4 (.I(i[4]), .O(o[4]));
	(* S = "TRUE" *)
	BUF dly5 (.I(i[5]), .O(o[5]));
	(* S = "TRUE" *)
	BUF dly6 (.I(i[6]), .O(o[6]));
	(* S = "TRUE" *)
	BUF dly7 (.I(i[7]), .O(o[7]));
	(* S = "TRUE" *)
	BUF dly8 (.I(i[8]), .O(o[8]));
	(* S = "TRUE" *)
	BUF dly9 (.I(i[9]), .O(o[9]));
	(* S = "TRUE" *)
	BUF dly10 (.I(i[10]), .O(o[10]));
	(* S = "TRUE" *)
	BUF dly11 (.I(i[11]), .O(o[11]));
	(* S = "TRUE" *)
	BUF dly12 (.I(i[12]), .O(o[12]));
	(* S = "TRUE" *)
	BUF dly13 (.I(i[13]), .O(o[13]));
	(* S = "TRUE" *)
	BUF dly14 (.I(i[14]), .O(o[14]));
	(* S = "TRUE" *)
	BUF dly15 (.I(i[15]), .O(o[15]));
	(* S = "TRUE" *)
	BUF dly16 (.I(i[16]), .O(o[16]));
	(* S = "TRUE" *)
	BUF dly17 (.I(i[17]), .O(o[17]));
	(* S = "TRUE" *)
	BUF dly18 (.I(i[18]), .O(o[18]));
	(* S = "TRUE" *)
	BUF dly19 (.I(i[19]), .O(o[19]));
	(* S = "TRUE" *)
	BUF dly20 (.I(i[20]), .O(o[20]));
	(* S = "TRUE" *)
	BUF dly21 (.I(i[21]), .O(o[21]));
	(* S = "TRUE" *)
	BUF dly22 (.I(i[22]), .O(o[22]));
	(* S = "TRUE" *)
	BUF dly23 (.I(i[23]), .O(o[23]));
	(* S = "TRUE" *)
	BUF dly24 (.I(i[24]), .O(o[24]));
	(* S = "TRUE" *)
	BUF dly25 (.I(i[25]), .O(o[25]));
	(* S = "TRUE" *)
	BUF dly26 (.I(i[26]), .O(o[26]));
	(* S = "TRUE" *)
	BUF dly27 (.I(i[27]), .O(o[27]));
	(* S = "TRUE" *)
	BUF dly28 (.I(i[28]), .O(o[28]));
	(* S = "TRUE" *)
	BUF dly29 (.I(i[29]), .O(o[29]));
	(* S = "TRUE" *)
	BUF dly30 (.I(i[30]), .O(o[30]));
	(* S = "TRUE" *)
	BUF dly31 (.I(i[31]), .O(o[31]));
	(* S = "TRUE" *)
	BUF dly32 (.I(i[32]), .O(o[32]));
	(* S = "TRUE" *)
	BUF dly33 (.I(i[33]), .O(o[33]));
	(* S = "TRUE" *)
	BUF dly34 (.I(i[34]), .O(o[34]));
	(* S = "TRUE" *)
	BUF dly35 (.I(i[35]), .O(o[35]));
	(* S = "TRUE" *)
	BUF dly36 (.I(i[36]), .O(o[36]));
	(* S = "TRUE" *)
	BUF dly37 (.I(i[37]), .O(o[37]));
	(* S = "TRUE" *)
	BUF dly38 (.I(i[38]), .O(o[38]));
	(* S = "TRUE" *)
	BUF dly39 (.I(i[39]), .O(o[39]));
	(* S = "TRUE" *)
	BUF dly40 (.I(i[40]), .O(o[40]));
	(* S = "TRUE" *)
	BUF dly41 (.I(i[41]), .O(o[41]));
	(* S = "TRUE" *)
	BUF dly42 (.I(i[42]), .O(o[42]));
	(* S = "TRUE" *)
	BUF dly43 (.I(i[43]), .O(o[43]));
	(* S = "TRUE" *)
	BUF dly44 (.I(i[44]), .O(o[44]));
	(* S = "TRUE" *)
	BUF dly45 (.I(i[45]), .O(o[45]));
	(* S = "TRUE" *)
	BUF dly46 (.I(i[46]), .O(o[46]));
	(* S = "TRUE" *)
	BUF dly47 (.I(i[47]), .O(o[47]));
	(* S = "TRUE" *)
	BUF dly48 (.I(i[48]), .O(o[48]));
	(* S = "TRUE" *)
	BUF dly49 (.I(i[49]), .O(o[49]));
	(* S = "TRUE" *)
	BUF dly50 (.I(i[50]), .O(o[50]));
	(* S = "TRUE" *)
	BUF dly51 (.I(i[51]), .O(o[51]));
	(* S = "TRUE" *)
	BUF dly52 (.I(i[52]), .O(o[52]));
	(* S = "TRUE" *)
	BUF dly53 (.I(i[53]), .O(o[53]));
	(* S = "TRUE" *)
	BUF dly54 (.I(i[54]), .O(o[54]));
	(* S = "TRUE" *)
	BUF dly55 (.I(i[55]), .O(o[55]));
	(* S = "TRUE" *)
	BUF dly56 (.I(i[56]), .O(o[56]));
	(* S = "TRUE" *)
	BUF dly57 (.I(i[57]), .O(o[57]));
	(* S = "TRUE" *)
	BUF dly58 (.I(i[58]), .O(o[58]));
	(* S = "TRUE" *)
	BUF dly59 (.I(i[59]), .O(o[59]));
	(* S = "TRUE" *)
	BUF dly60 (.I(i[60]), .O(o[60]));
	(* S = "TRUE" *)
	BUF dly61 (.I(i[61]), .O(o[61]));
	(* S = "TRUE" *)
	BUF dly62 (.I(i[62]), .O(o[62]));
	(* S = "TRUE" *)
	BUF dly63 (.I(i[63]), .O(o[63]));
endmodule

// macexp ADDER 5
// macexp $size 5
// macexp $instance
// macexp i0
// macexp i1
// macexp s

module adder_5 ( i0, i1, s );
	input [4:0] i0;
	input [4:0] i1;
	output [4:0] s;
	wire [7:0] cig_s;
	reg  [7:0] cig_si;
	reg  [7:0] cig_di;
	wire [7:0] cig_co;
	wire [4:0] si;
	wire [1:0] ci;
	assign si = i0 ^ i1;
	always @ (si or i0) begin
	cig_si = 8'h0;
	cig_di = 8'h0;
	cig_si[4:0] = si;
	cig_di[4:0] = i0;
	end
	assign ci[0] = 1'b0;
	CARRY4 cry0 (
	// Outputs
	.O(cig_s[3:0]),
	.CO(cig_co[3:0]),
	// Inputs
	.S(cig_si[3:0]),
	.DI(cig_di[3:0]),
	.CI(ci[0]),
	.CYINIT(1'b0)
	);
	assign ci[1] = cig_co[3];
	CARRY4 cry1 (
	// Outputs
	.O(cig_s[7:4]),
	.CO(cig_co[7:4]),
	// Inputs
	.S(cig_si[7:4]),
	.DI(cig_di[7:4]),
	.CI(ci[1]),
	.CYINIT(1'b0)
	);
	assign s = cig_s[4:0];
endmodule

// macexp DLY100_SEL 5
// macexp $depth 1
// macexp $size 66
// macexp $instance
// macexp i
// macexp o

module dly1_66 ( i, o );
	input [65:0] i;
	output [65:0] o;
	(* S = "TRUE" *)
	BUF dly0 (.I(i[0]), .O(o[0]));
	(* S = "TRUE" *)
	BUF dly1 (.I(i[1]), .O(o[1]));
	(* S = "TRUE" *)
	BUF dly2 (.I(i[2]), .O(o[2]));
	(* S = "TRUE" *)
	BUF dly3 (.I(i[3]), .O(o[3]));
	(* S = "TRUE" *)
	BUF dly4 (.I(i[4]), .O(o[4]));
	(* S = "TRUE" *)
	BUF dly5 (.I(i[5]), .O(o[5]));
	(* S = "TRUE" *)
	BUF dly6 (.I(i[6]), .O(o[6]));
	(* S = "TRUE" *)
	BUF dly7 (.I(i[7]), .O(o[7]));
	(* S = "TRUE" *)
	BUF dly8 (.I(i[8]), .O(o[8]));
	(* S = "TRUE" *)
	BUF dly9 (.I(i[9]), .O(o[9]));
	(* S = "TRUE" *)
	BUF dly10 (.I(i[10]), .O(o[10]));
	(* S = "TRUE" *)
	BUF dly11 (.I(i[11]), .O(o[11]));
	(* S = "TRUE" *)
	BUF dly12 (.I(i[12]), .O(o[12]));
	(* S = "TRUE" *)
	BUF dly13 (.I(i[13]), .O(o[13]));
	(* S = "TRUE" *)
	BUF dly14 (.I(i[14]), .O(o[14]));
	(* S = "TRUE" *)
	BUF dly15 (.I(i[15]), .O(o[15]));
	(* S = "TRUE" *)
	BUF dly16 (.I(i[16]), .O(o[16]));
	(* S = "TRUE" *)
	BUF dly17 (.I(i[17]), .O(o[17]));
	(* S = "TRUE" *)
	BUF dly18 (.I(i[18]), .O(o[18]));
	(* S = "TRUE" *)
	BUF dly19 (.I(i[19]), .O(o[19]));
	(* S = "TRUE" *)
	BUF dly20 (.I(i[20]), .O(o[20]));
	(* S = "TRUE" *)
	BUF dly21 (.I(i[21]), .O(o[21]));
	(* S = "TRUE" *)
	BUF dly22 (.I(i[22]), .O(o[22]));
	(* S = "TRUE" *)
	BUF dly23 (.I(i[23]), .O(o[23]));
	(* S = "TRUE" *)
	BUF dly24 (.I(i[24]), .O(o[24]));
	(* S = "TRUE" *)
	BUF dly25 (.I(i[25]), .O(o[25]));
	(* S = "TRUE" *)
	BUF dly26 (.I(i[26]), .O(o[26]));
	(* S = "TRUE" *)
	BUF dly27 (.I(i[27]), .O(o[27]));
	(* S = "TRUE" *)
	BUF dly28 (.I(i[28]), .O(o[28]));
	(* S = "TRUE" *)
	BUF dly29 (.I(i[29]), .O(o[29]));
	(* S = "TRUE" *)
	BUF dly30 (.I(i[30]), .O(o[30]));
	(* S = "TRUE" *)
	BUF dly31 (.I(i[31]), .O(o[31]));
	(* S = "TRUE" *)
	BUF dly32 (.I(i[32]), .O(o[32]));
	(* S = "TRUE" *)
	BUF dly33 (.I(i[33]), .O(o[33]));
	(* S = "TRUE" *)
	BUF dly34 (.I(i[34]), .O(o[34]));
	(* S = "TRUE" *)
	BUF dly35 (.I(i[35]), .O(o[35]));
	(* S = "TRUE" *)
	BUF dly36 (.I(i[36]), .O(o[36]));
	(* S = "TRUE" *)
	BUF dly37 (.I(i[37]), .O(o[37]));
	(* S = "TRUE" *)
	BUF dly38 (.I(i[38]), .O(o[38]));
	(* S = "TRUE" *)
	BUF dly39 (.I(i[39]), .O(o[39]));
	(* S = "TRUE" *)
	BUF dly40 (.I(i[40]), .O(o[40]));
	(* S = "TRUE" *)
	BUF dly41 (.I(i[41]), .O(o[41]));
	(* S = "TRUE" *)
	BUF dly42 (.I(i[42]), .O(o[42]));
	(* S = "TRUE" *)
	BUF dly43 (.I(i[43]), .O(o[43]));
	(* S = "TRUE" *)
	BUF dly44 (.I(i[44]), .O(o[44]));
	(* S = "TRUE" *)
	BUF dly45 (.I(i[45]), .O(o[45]));
	(* S = "TRUE" *)
	BUF dly46 (.I(i[46]), .O(o[46]));
	(* S = "TRUE" *)
	BUF dly47 (.I(i[47]), .O(o[47]));
	(* S = "TRUE" *)
	BUF dly48 (.I(i[48]), .O(o[48]));
	(* S = "TRUE" *)
	BUF dly49 (.I(i[49]), .O(o[49]));
	(* S = "TRUE" *)
	BUF dly50 (.I(i[50]), .O(o[50]));
	(* S = "TRUE" *)
	BUF dly51 (.I(i[51]), .O(o[51]));
	(* S = "TRUE" *)
	BUF dly52 (.I(i[52]), .O(o[52]));
	(* S = "TRUE" *)
	BUF dly53 (.I(i[53]), .O(o[53]));
	(* S = "TRUE" *)
	BUF dly54 (.I(i[54]), .O(o[54]));
	(* S = "TRUE" *)
	BUF dly55 (.I(i[55]), .O(o[55]));
	(* S = "TRUE" *)
	BUF dly56 (.I(i[56]), .O(o[56]));
	(* S = "TRUE" *)
	BUF dly57 (.I(i[57]), .O(o[57]));
	(* S = "TRUE" *)
	BUF dly58 (.I(i[58]), .O(o[58]));
	(* S = "TRUE" *)
	BUF dly59 (.I(i[59]), .O(o[59]));
	(* S = "TRUE" *)
	BUF dly60 (.I(i[60]), .O(o[60]));
	(* S = "TRUE" *)
	BUF dly61 (.I(i[61]), .O(o[61]));
	(* S = "TRUE" *)
	BUF dly62 (.I(i[62]), .O(o[62]));
	(* S = "TRUE" *)
	BUF dly63 (.I(i[63]), .O(o[63]));
	(* S = "TRUE" *)
	BUF dly64 (.I(i[64]), .O(o[64]));
	(* S = "TRUE" *)
	BUF dly65 (.I(i[65]), .O(o[65]));
endmodule

// macexp DFF_KEEP 5
// macexp $size 66
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_66 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_66 "true";
	// synthesis attribute equivalent_register_removal dff_keep_66 "no";
	// synthesis attribute shift_extract dff_keep_66 "no";
	// synthesis attribute shreg_extract dff_keep_66 "no";
	input clk;
	input [65:0] d;
	// synthesis attribute keep q "true";
	output [65:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
	(* S = "TRUE" *)
	FD q_9 (
	.Q(q[9]),
	.C(clk),
	.D(d[9])
	);
	(* S = "TRUE" *)
	FD q_10 (
	.Q(q[10]),
	.C(clk),
	.D(d[10])
	);
	(* S = "TRUE" *)
	FD q_11 (
	.Q(q[11]),
	.C(clk),
	.D(d[11])
	);
	(* S = "TRUE" *)
	FD q_12 (
	.Q(q[12]),
	.C(clk),
	.D(d[12])
	);
	(* S = "TRUE" *)
	FD q_13 (
	.Q(q[13]),
	.C(clk),
	.D(d[13])
	);
	(* S = "TRUE" *)
	FD q_14 (
	.Q(q[14]),
	.C(clk),
	.D(d[14])
	);
	(* S = "TRUE" *)
	FD q_15 (
	.Q(q[15]),
	.C(clk),
	.D(d[15])
	);
	(* S = "TRUE" *)
	FD q_16 (
	.Q(q[16]),
	.C(clk),
	.D(d[16])
	);
	(* S = "TRUE" *)
	FD q_17 (
	.Q(q[17]),
	.C(clk),
	.D(d[17])
	);
	(* S = "TRUE" *)
	FD q_18 (
	.Q(q[18]),
	.C(clk),
	.D(d[18])
	);
	(* S = "TRUE" *)
	FD q_19 (
	.Q(q[19]),
	.C(clk),
	.D(d[19])
	);
	(* S = "TRUE" *)
	FD q_20 (
	.Q(q[20]),
	.C(clk),
	.D(d[20])
	);
	(* S = "TRUE" *)
	FD q_21 (
	.Q(q[21]),
	.C(clk),
	.D(d[21])
	);
	(* S = "TRUE" *)
	FD q_22 (
	.Q(q[22]),
	.C(clk),
	.D(d[22])
	);
	(* S = "TRUE" *)
	FD q_23 (
	.Q(q[23]),
	.C(clk),
	.D(d[23])
	);
	(* S = "TRUE" *)
	FD q_24 (
	.Q(q[24]),
	.C(clk),
	.D(d[24])
	);
	(* S = "TRUE" *)
	FD q_25 (
	.Q(q[25]),
	.C(clk),
	.D(d[25])
	);
	(* S = "TRUE" *)
	FD q_26 (
	.Q(q[26]),
	.C(clk),
	.D(d[26])
	);
	(* S = "TRUE" *)
	FD q_27 (
	.Q(q[27]),
	.C(clk),
	.D(d[27])
	);
	(* S = "TRUE" *)
	FD q_28 (
	.Q(q[28]),
	.C(clk),
	.D(d[28])
	);
	(* S = "TRUE" *)
	FD q_29 (
	.Q(q[29]),
	.C(clk),
	.D(d[29])
	);
	(* S = "TRUE" *)
	FD q_30 (
	.Q(q[30]),
	.C(clk),
	.D(d[30])
	);
	(* S = "TRUE" *)
	FD q_31 (
	.Q(q[31]),
	.C(clk),
	.D(d[31])
	);
	(* S = "TRUE" *)
	FD q_32 (
	.Q(q[32]),
	.C(clk),
	.D(d[32])
	);
	(* S = "TRUE" *)
	FD q_33 (
	.Q(q[33]),
	.C(clk),
	.D(d[33])
	);
	(* S = "TRUE" *)
	FD q_34 (
	.Q(q[34]),
	.C(clk),
	.D(d[34])
	);
	(* S = "TRUE" *)
	FD q_35 (
	.Q(q[35]),
	.C(clk),
	.D(d[35])
	);
	(* S = "TRUE" *)
	FD q_36 (
	.Q(q[36]),
	.C(clk),
	.D(d[36])
	);
	(* S = "TRUE" *)
	FD q_37 (
	.Q(q[37]),
	.C(clk),
	.D(d[37])
	);
	(* S = "TRUE" *)
	FD q_38 (
	.Q(q[38]),
	.C(clk),
	.D(d[38])
	);
	(* S = "TRUE" *)
	FD q_39 (
	.Q(q[39]),
	.C(clk),
	.D(d[39])
	);
	(* S = "TRUE" *)
	FD q_40 (
	.Q(q[40]),
	.C(clk),
	.D(d[40])
	);
	(* S = "TRUE" *)
	FD q_41 (
	.Q(q[41]),
	.C(clk),
	.D(d[41])
	);
	(* S = "TRUE" *)
	FD q_42 (
	.Q(q[42]),
	.C(clk),
	.D(d[42])
	);
	(* S = "TRUE" *)
	FD q_43 (
	.Q(q[43]),
	.C(clk),
	.D(d[43])
	);
	(* S = "TRUE" *)
	FD q_44 (
	.Q(q[44]),
	.C(clk),
	.D(d[44])
	);
	(* S = "TRUE" *)
	FD q_45 (
	.Q(q[45]),
	.C(clk),
	.D(d[45])
	);
	(* S = "TRUE" *)
	FD q_46 (
	.Q(q[46]),
	.C(clk),
	.D(d[46])
	);
	(* S = "TRUE" *)
	FD q_47 (
	.Q(q[47]),
	.C(clk),
	.D(d[47])
	);
	(* S = "TRUE" *)
	FD q_48 (
	.Q(q[48]),
	.C(clk),
	.D(d[48])
	);
	(* S = "TRUE" *)
	FD q_49 (
	.Q(q[49]),
	.C(clk),
	.D(d[49])
	);
	(* S = "TRUE" *)
	FD q_50 (
	.Q(q[50]),
	.C(clk),
	.D(d[50])
	);
	(* S = "TRUE" *)
	FD q_51 (
	.Q(q[51]),
	.C(clk),
	.D(d[51])
	);
	(* S = "TRUE" *)
	FD q_52 (
	.Q(q[52]),
	.C(clk),
	.D(d[52])
	);
	(* S = "TRUE" *)
	FD q_53 (
	.Q(q[53]),
	.C(clk),
	.D(d[53])
	);
	(* S = "TRUE" *)
	FD q_54 (
	.Q(q[54]),
	.C(clk),
	.D(d[54])
	);
	(* S = "TRUE" *)
	FD q_55 (
	.Q(q[55]),
	.C(clk),
	.D(d[55])
	);
	(* S = "TRUE" *)
	FD q_56 (
	.Q(q[56]),
	.C(clk),
	.D(d[56])
	);
	(* S = "TRUE" *)
	FD q_57 (
	.Q(q[57]),
	.C(clk),
	.D(d[57])
	);
	(* S = "TRUE" *)
	FD q_58 (
	.Q(q[58]),
	.C(clk),
	.D(d[58])
	);
	(* S = "TRUE" *)
	FD q_59 (
	.Q(q[59]),
	.C(clk),
	.D(d[59])
	);
	(* S = "TRUE" *)
	FD q_60 (
	.Q(q[60]),
	.C(clk),
	.D(d[60])
	);
	(* S = "TRUE" *)
	FD q_61 (
	.Q(q[61]),
	.C(clk),
	.D(d[61])
	);
	(* S = "TRUE" *)
	FD q_62 (
	.Q(q[62]),
	.C(clk),
	.D(d[62])
	);
	(* S = "TRUE" *)
	FD q_63 (
	.Q(q[63]),
	.C(clk),
	.D(d[63])
	);
	(* S = "TRUE" *)
	FD q_64 (
	.Q(q[64]),
	.C(clk),
	.D(d[64])
	);
	(* S = "TRUE" *)
	FD q_65 (
	.Q(q[65]),
	.C(clk),
	.D(d[65])
	);
endmodule

// macexp DFF_KEEP 5
// macexp $size 24
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_24 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_24 "true";
	// synthesis attribute equivalent_register_removal dff_keep_24 "no";
	// synthesis attribute shift_extract dff_keep_24 "no";
	// synthesis attribute shreg_extract dff_keep_24 "no";
	input clk;
	input [23:0] d;
	// synthesis attribute keep q "true";
	output [23:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
	(* S = "TRUE" *)
	FD q_9 (
	.Q(q[9]),
	.C(clk),
	.D(d[9])
	);
	(* S = "TRUE" *)
	FD q_10 (
	.Q(q[10]),
	.C(clk),
	.D(d[10])
	);
	(* S = "TRUE" *)
	FD q_11 (
	.Q(q[11]),
	.C(clk),
	.D(d[11])
	);
	(* S = "TRUE" *)
	FD q_12 (
	.Q(q[12]),
	.C(clk),
	.D(d[12])
	);
	(* S = "TRUE" *)
	FD q_13 (
	.Q(q[13]),
	.C(clk),
	.D(d[13])
	);
	(* S = "TRUE" *)
	FD q_14 (
	.Q(q[14]),
	.C(clk),
	.D(d[14])
	);
	(* S = "TRUE" *)
	FD q_15 (
	.Q(q[15]),
	.C(clk),
	.D(d[15])
	);
	(* S = "TRUE" *)
	FD q_16 (
	.Q(q[16]),
	.C(clk),
	.D(d[16])
	);
	(* S = "TRUE" *)
	FD q_17 (
	.Q(q[17]),
	.C(clk),
	.D(d[17])
	);
	(* S = "TRUE" *)
	FD q_18 (
	.Q(q[18]),
	.C(clk),
	.D(d[18])
	);
	(* S = "TRUE" *)
	FD q_19 (
	.Q(q[19]),
	.C(clk),
	.D(d[19])
	);
	(* S = "TRUE" *)
	FD q_20 (
	.Q(q[20]),
	.C(clk),
	.D(d[20])
	);
	(* S = "TRUE" *)
	FD q_21 (
	.Q(q[21]),
	.C(clk),
	.D(d[21])
	);
	(* S = "TRUE" *)
	FD q_22 (
	.Q(q[22]),
	.C(clk),
	.D(d[22])
	);
	(* S = "TRUE" *)
	FD q_23 (
	.Q(q[23]),
	.C(clk),
	.D(d[23])
	);
endmodule

// macexp DFF_KEEP 5
// macexp $size 4
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_4 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_4 "true";
	// synthesis attribute equivalent_register_removal dff_keep_4 "no";
	// synthesis attribute shift_extract dff_keep_4 "no";
	// synthesis attribute shreg_extract dff_keep_4 "no";
	input clk;
	input [3:0] d;
	// synthesis attribute keep q "true";
	output [3:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
endmodule

// macexp DFFC_KEEP 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_keep_1 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_keep_1 "true";
	// synthesis attribute equivalent_register_removal dffc_keep_1 "no";
	// synthesis attribute shift_extract dffc_keep_1 "no";
	// synthesis attribute shreg_extract dffc_keep_1 "no";
	input clk;
	input reset;
	input d;
	// synthesis attribute keep q "true";
	output q;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	(* S = "TRUE" *)
	FDR q0 (
	.Q(q),
	.C(clk),
	.R(reset),
	.D(d)
	);
endmodule

// macexp DFFC 6
// macexp $size 10
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_10 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_10 "true";
	input clk;
	input reset;
	input [9:0] d;
	output [9:0] q;
	reg [9:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 10'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFC_KEEP 6
// macexp $size 18
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_keep_18 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_keep_18 "true";
	// synthesis attribute equivalent_register_removal dffc_keep_18 "no";
	// synthesis attribute shift_extract dffc_keep_18 "no";
	// synthesis attribute shreg_extract dffc_keep_18 "no";
	input clk;
	input reset;
	input [17:0] d;
	// synthesis attribute keep q "true";
	output [17:0] q;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	(* S = "TRUE" *)
	FDR q_0 (
	.Q(q[0]),
	.C(clk),
	.R(reset),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FDR q_1 (
	.Q(q[1]),
	.C(clk),
	.R(reset),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FDR q_2 (
	.Q(q[2]),
	.C(clk),
	.R(reset),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FDR q_3 (
	.Q(q[3]),
	.C(clk),
	.R(reset),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FDR q_4 (
	.Q(q[4]),
	.C(clk),
	.R(reset),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FDR q_5 (
	.Q(q[5]),
	.C(clk),
	.R(reset),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FDR q_6 (
	.Q(q[6]),
	.C(clk),
	.R(reset),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FDR q_7 (
	.Q(q[7]),
	.C(clk),
	.R(reset),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FDR q_8 (
	.Q(q[8]),
	.C(clk),
	.R(reset),
	.D(d[8])
	);
	(* S = "TRUE" *)
	FDR q_9 (
	.Q(q[9]),
	.C(clk),
	.R(reset),
	.D(d[9])
	);
	(* S = "TRUE" *)
	FDR q_10 (
	.Q(q[10]),
	.C(clk),
	.R(reset),
	.D(d[10])
	);
	(* S = "TRUE" *)
	FDR q_11 (
	.Q(q[11]),
	.C(clk),
	.R(reset),
	.D(d[11])
	);
	(* S = "TRUE" *)
	FDR q_12 (
	.Q(q[12]),
	.C(clk),
	.R(reset),
	.D(d[12])
	);
	(* S = "TRUE" *)
	FDR q_13 (
	.Q(q[13]),
	.C(clk),
	.R(reset),
	.D(d[13])
	);
	(* S = "TRUE" *)
	FDR q_14 (
	.Q(q[14]),
	.C(clk),
	.R(reset),
	.D(d[14])
	);
	(* S = "TRUE" *)
	FDR q_15 (
	.Q(q[15]),
	.C(clk),
	.R(reset),
	.D(d[15])
	);
	(* S = "TRUE" *)
	FDR q_16 (
	.Q(q[16]),
	.C(clk),
	.R(reset),
	.D(d[16])
	);
	(* S = "TRUE" *)
	FDR q_17 (
	.Q(q[17]),
	.C(clk),
	.R(reset),
	.D(d[17])
	);
endmodule

// macexp DLY100_SEL 5
// macexp $depth 3
// macexp $size 9
// macexp $instance
// macexp i
// macexp o

module dly3_9 ( i, o );
	input [8:0] i;
	output [8:0] o;
	wire [8:0] n0;
	wire [8:0] n1;
	wire [8:0] n2;
	wire [8:0] n3;
	assign n0 = i;
	(* S = "TRUE" *)
	BUF dly00 (.I(n0[0]), .O(n1[0]));
	(* S = "TRUE" *)
	BUF dly01 (.I(n0[1]), .O(n1[1]));
	(* S = "TRUE" *)
	BUF dly02 (.I(n0[2]), .O(n1[2]));
	(* S = "TRUE" *)
	BUF dly03 (.I(n0[3]), .O(n1[3]));
	(* S = "TRUE" *)
	BUF dly04 (.I(n0[4]), .O(n1[4]));
	(* S = "TRUE" *)
	BUF dly05 (.I(n0[5]), .O(n1[5]));
	(* S = "TRUE" *)
	BUF dly06 (.I(n0[6]), .O(n1[6]));
	(* S = "TRUE" *)
	BUF dly07 (.I(n0[7]), .O(n1[7]));
	(* S = "TRUE" *)
	BUF dly08 (.I(n0[8]), .O(n1[8]));
	(* S = "TRUE" *)
	BUF dly10 (.I(n1[0]), .O(n2[0]));
	(* S = "TRUE" *)
	BUF dly11 (.I(n1[1]), .O(n2[1]));
	(* S = "TRUE" *)
	BUF dly12 (.I(n1[2]), .O(n2[2]));
	(* S = "TRUE" *)
	BUF dly13 (.I(n1[3]), .O(n2[3]));
	(* S = "TRUE" *)
	BUF dly14 (.I(n1[4]), .O(n2[4]));
	(* S = "TRUE" *)
	BUF dly15 (.I(n1[5]), .O(n2[5]));
	(* S = "TRUE" *)
	BUF dly16 (.I(n1[6]), .O(n2[6]));
	(* S = "TRUE" *)
	BUF dly17 (.I(n1[7]), .O(n2[7]));
	(* S = "TRUE" *)
	BUF dly18 (.I(n1[8]), .O(n2[8]));
	(* S = "TRUE" *)
	BUF dly20 (.I(n2[0]), .O(n3[0]));
	(* S = "TRUE" *)
	BUF dly21 (.I(n2[1]), .O(n3[1]));
	(* S = "TRUE" *)
	BUF dly22 (.I(n2[2]), .O(n3[2]));
	(* S = "TRUE" *)
	BUF dly23 (.I(n2[3]), .O(n3[3]));
	(* S = "TRUE" *)
	BUF dly24 (.I(n2[4]), .O(n3[4]));
	(* S = "TRUE" *)
	BUF dly25 (.I(n2[5]), .O(n3[5]));
	(* S = "TRUE" *)
	BUF dly26 (.I(n2[6]), .O(n3[6]));
	(* S = "TRUE" *)
	BUF dly27 (.I(n2[7]), .O(n3[7]));
	(* S = "TRUE" *)
	BUF dly28 (.I(n2[8]), .O(n3[8]));
	assign o = n3;
endmodule

// macexp DFFL 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp ld
// macexp d
// macexp q

module dffl_1 ( clk, ld, d, q );
	// synthesis attribute keep_hierarchy dffl_1 "true";
	input clk;
	input d;
	input ld;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	// leda XV2P_1006 off Multiple synchronous resets detected
	// leda XV2P_1007 off Multiple synchronous resets detected
	// leda G_551_1_K off Multiple synchronous resets detected
	if (ld)
	q <= d;
	// leda XV2P_1006 on Multiple synchronous resets detected
	// leda XV2P_1007 on Multiple synchronous resets detected
	// leda G_551_1_K on Multiple synchronous resets detected
	end
endmodule

// macexp DFFL 6
// macexp $size 18
// macexp $instance
// macexp clk
// macexp ld
// macexp d
// macexp q

module dffl_18 ( clk, ld, d, q );
	// synthesis attribute keep_hierarchy dffl_18 "true";
	input clk;
	input ld;
	input [17:0] d;
	output [17:0] q;
	reg [17:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	// leda XV2P_1006 off Multiple synchronous resets detected
	// leda XV2P_1007 off Multiple synchronous resets detected
	// leda G_551_1_K off Multiple synchronous resets detected
	if (ld)
	q <= d;
	// leda XV2P_1006 on Multiple synchronous resets detected
	// leda XV2P_1007 on Multiple synchronous resets detected
	// leda G_551_1_K on Multiple synchronous resets detected
	end
endmodule

// macexp DFFL 6
// macexp $size 32
// macexp $instance
// macexp clk
// macexp ld
// macexp d
// macexp q

module dffl_32 ( clk, ld, d, q );
	// synthesis attribute keep_hierarchy dffl_32 "true";
	input clk;
	input ld;
	input [31:0] d;
	output [31:0] q;
	reg [31:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	// leda XV2P_1006 off Multiple synchronous resets detected
	// leda XV2P_1007 off Multiple synchronous resets detected
	// leda G_551_1_K off Multiple synchronous resets detected
	if (ld)
	q <= d;
	// leda XV2P_1006 on Multiple synchronous resets detected
	// leda XV2P_1007 on Multiple synchronous resets detected
	// leda G_551_1_K on Multiple synchronous resets detected
	end
endmodule

// macexp DFFL 6
// macexp $size 64
// macexp $instance
// macexp clk
// macexp ld
// macexp d
// macexp q

module dffl_64 ( clk, ld, d, q );
	// synthesis attribute keep_hierarchy dffl_64 "true";
	input clk;
	input ld;
	input [63:0] d;
	output [63:0] q;
	reg [63:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	// leda XV2P_1006 off Multiple synchronous resets detected
	// leda XV2P_1007 off Multiple synchronous resets detected
	// leda G_551_1_K off Multiple synchronous resets detected
	if (ld)
	q <= d;
	// leda XV2P_1006 on Multiple synchronous resets detected
	// leda XV2P_1007 on Multiple synchronous resets detected
	// leda G_551_1_K on Multiple synchronous resets detected
	end
endmodule

// macexp DFFC 6
// macexp $size 16
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_16 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_16 "true";
	input clk;
	input reset;
	input [15:0] d;
	output [15:0] q;
	reg [15:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 16'b0;
	else
	q <= d;
	end
endmodule

`endcelldefine

